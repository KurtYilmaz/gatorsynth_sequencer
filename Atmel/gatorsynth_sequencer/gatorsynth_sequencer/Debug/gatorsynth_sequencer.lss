
gatorsynth_sequencer.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000016d8  00400000  00400000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     000004a8  20000000  004016d8  00020000  2**3
                  CONTENTS, ALLOC, LOAD, CODE
  2 .bss          00000024  200004a8  00401b80  000204a8  2**2
                  ALLOC
  3 .stack        00003004  200004cc  00401ba4  000204a8  2**0
                  ALLOC
  4 .ARM.attributes 0000002a  00000000  00000000  000204a8  2**0
                  CONTENTS, READONLY
  5 .comment      00000059  00000000  00000000  000204d2  2**0
                  CONTENTS, READONLY
  6 .debug_info   00003c7e  00000000  00000000  0002052b  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000118d  00000000  00000000  000241a9  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    00001065  00000000  00000000  00025336  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 000003f8  00000000  00000000  0002639b  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00000328  00000000  00000000  00026793  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macro  000043b8  00000000  00000000  00026abb  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   00009418  00000000  00000000  0002ae73  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    0003c809  00000000  00000000  0003428b  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  0000084c  00000000  00000000  00070a94  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00400000 <_sfixed>:
  400000:	200034d0 	.word	0x200034d0
  400004:	00401165 	.word	0x00401165
  400008:	00401161 	.word	0x00401161
  40000c:	00401161 	.word	0x00401161
  400010:	00401161 	.word	0x00401161
  400014:	00401161 	.word	0x00401161
  400018:	00401161 	.word	0x00401161
	...
  40002c:	00401161 	.word	0x00401161
  400030:	00401161 	.word	0x00401161
  400034:	00000000 	.word	0x00000000
  400038:	00401161 	.word	0x00401161
  40003c:	00401161 	.word	0x00401161
  400040:	00401161 	.word	0x00401161
  400044:	00401161 	.word	0x00401161
  400048:	00401161 	.word	0x00401161
  40004c:	00401161 	.word	0x00401161
  400050:	00401161 	.word	0x00401161
  400054:	00401161 	.word	0x00401161
  400058:	00401161 	.word	0x00401161
  40005c:	00000000 	.word	0x00000000
  400060:	00401161 	.word	0x00401161
  400064:	00401161 	.word	0x00401161
  400068:	00401161 	.word	0x00401161
  40006c:	00401161 	.word	0x00401161
  400070:	00401565 	.word	0x00401565
  400074:	004009fd 	.word	0x004009fd
  400078:	00401161 	.word	0x00401161
  40007c:	00401161 	.word	0x00401161
  400080:	00401161 	.word	0x00401161
  400084:	00401161 	.word	0x00401161
  400088:	00000000 	.word	0x00000000
  40008c:	00401161 	.word	0x00401161
  400090:	00401161 	.word	0x00401161
  400094:	00401161 	.word	0x00401161
  400098:	00401161 	.word	0x00401161
  40009c:	00400fc1 	.word	0x00400fc1
  4000a0:	00401161 	.word	0x00401161
  4000a4:	00401161 	.word	0x00401161
  4000a8:	00401161 	.word	0x00401161
  4000ac:	00401161 	.word	0x00401161
  4000b0:	00401161 	.word	0x00401161
  4000b4:	00401161 	.word	0x00401161
  4000b8:	00401161 	.word	0x00401161
  4000bc:	00401161 	.word	0x00401161

004000c0 <__do_global_dtors_aux>:
  4000c0:	b510      	push	{r4, lr}
  4000c2:	4c05      	ldr	r4, [pc, #20]	; (4000d8 <__do_global_dtors_aux+0x18>)
  4000c4:	7823      	ldrb	r3, [r4, #0]
  4000c6:	b933      	cbnz	r3, 4000d6 <__do_global_dtors_aux+0x16>
  4000c8:	4b04      	ldr	r3, [pc, #16]	; (4000dc <__do_global_dtors_aux+0x1c>)
  4000ca:	b113      	cbz	r3, 4000d2 <__do_global_dtors_aux+0x12>
  4000cc:	4804      	ldr	r0, [pc, #16]	; (4000e0 <__do_global_dtors_aux+0x20>)
  4000ce:	f3af 8000 	nop.w
  4000d2:	2301      	movs	r3, #1
  4000d4:	7023      	strb	r3, [r4, #0]
  4000d6:	bd10      	pop	{r4, pc}
  4000d8:	200004a8 	.word	0x200004a8
  4000dc:	00000000 	.word	0x00000000
  4000e0:	004016d8 	.word	0x004016d8

004000e4 <frame_dummy>:
  4000e4:	4b08      	ldr	r3, [pc, #32]	; (400108 <frame_dummy+0x24>)
  4000e6:	b510      	push	{r4, lr}
  4000e8:	b11b      	cbz	r3, 4000f2 <frame_dummy+0xe>
  4000ea:	4908      	ldr	r1, [pc, #32]	; (40010c <frame_dummy+0x28>)
  4000ec:	4808      	ldr	r0, [pc, #32]	; (400110 <frame_dummy+0x2c>)
  4000ee:	f3af 8000 	nop.w
  4000f2:	4808      	ldr	r0, [pc, #32]	; (400114 <frame_dummy+0x30>)
  4000f4:	6803      	ldr	r3, [r0, #0]
  4000f6:	b903      	cbnz	r3, 4000fa <frame_dummy+0x16>
  4000f8:	bd10      	pop	{r4, pc}
  4000fa:	4b07      	ldr	r3, [pc, #28]	; (400118 <frame_dummy+0x34>)
  4000fc:	2b00      	cmp	r3, #0
  4000fe:	d0fb      	beq.n	4000f8 <frame_dummy+0x14>
  400100:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  400104:	4718      	bx	r3
  400106:	bf00      	nop
  400108:	00000000 	.word	0x00000000
  40010c:	200004ac 	.word	0x200004ac
  400110:	004016d8 	.word	0x004016d8
  400114:	004016d8 	.word	0x004016d8
  400118:	00000000 	.word	0x00000000

0040011c <Encoder_isRight>:
#include <stdbool.h>

uint8_t A_seq;
uint8_t B_seq;

 void Encoder_isRight(uint32_t A, uint32_t B){
  40011c:	b470      	push	{r4, r5, r6}

	//read Encoder input A
	bool A_in = REG_PIOC_PDSR & A;
  40011e:	4b17      	ldr	r3, [pc, #92]	; (40017c <Encoder_isRight+0x60>)
  400120:	681e      	ldr	r6, [r3, #0]
	//read Encoder input B
	bool B_in = REG_PIOC_PDSR & B;
  400122:	681b      	ldr	r3, [r3, #0]
	
	A_seq = A_seq << 1;
	A_seq |= A_in;
	
	B_seq = B_seq << 1;
  400124:	4c16      	ldr	r4, [pc, #88]	; (400180 <Encoder_isRight+0x64>)
	B_seq |= B_in;
  400126:	7822      	ldrb	r2, [r4, #0]
  400128:	420b      	tst	r3, r1
  40012a:	bf14      	ite	ne
  40012c:	2301      	movne	r3, #1
  40012e:	2300      	moveq	r3, #0
  400130:	ea43 0242 	orr.w	r2, r3, r2, lsl #1
	//read Encoder input A
	bool A_in = REG_PIOC_PDSR & A;
	//read Encoder input B
	bool B_in = REG_PIOC_PDSR & B;
	
	A_seq = A_seq << 1;
  400134:	4913      	ldr	r1, [pc, #76]	; (400184 <Encoder_isRight+0x68>)
	A_seq |= A_in;
	
	B_seq = B_seq << 1;
	B_seq |= B_in;
	
	A_seq &= 0b00001111;
  400136:	780d      	ldrb	r5, [r1, #0]
  400138:	4206      	tst	r6, r0
  40013a:	bf14      	ite	ne
  40013c:	2301      	movne	r3, #1
  40013e:	2300      	moveq	r3, #0
  400140:	ea43 0345 	orr.w	r3, r3, r5, lsl #1
  400144:	f003 030f 	and.w	r3, r3, #15
  400148:	700b      	strb	r3, [r1, #0]
	B_seq &= 0b00001111;
  40014a:	f002 020f 	and.w	r2, r2, #15
  40014e:	7022      	strb	r2, [r4, #0]


	//return true if turned right
	if ((A_seq == 0b00001001) && (B_seq == 0b00000011)){
  400150:	2b09      	cmp	r3, #9
  400152:	d107      	bne.n	400164 <Encoder_isRight+0x48>
  400154:	2a03      	cmp	r2, #3
  400156:	d10e      	bne.n	400176 <Encoder_isRight+0x5a>
		REG_PIOB_SODR |= PIO_PER_P3; //set output high on PB14 as default
  400158:	4a0b      	ldr	r2, [pc, #44]	; (400188 <Encoder_isRight+0x6c>)
  40015a:	6813      	ldr	r3, [r2, #0]
  40015c:	f043 0308 	orr.w	r3, r3, #8
  400160:	6013      	str	r3, [r2, #0]
  400162:	e008      	b.n	400176 <Encoder_isRight+0x5a>
	}

	else if ((A_seq == 0b00000011) && (B_seq == 0b00001001)){
  400164:	2b03      	cmp	r3, #3
  400166:	d106      	bne.n	400176 <Encoder_isRight+0x5a>
  400168:	2a09      	cmp	r2, #9
  40016a:	d104      	bne.n	400176 <Encoder_isRight+0x5a>
		REG_PIOB_CODR |= PIO_PER_P3; //set output high on PB14 as default
  40016c:	4a07      	ldr	r2, [pc, #28]	; (40018c <Encoder_isRight+0x70>)
  40016e:	6813      	ldr	r3, [r2, #0]
  400170:	f043 0308 	orr.w	r3, r3, #8
  400174:	6013      	str	r3, [r2, #0]
	}


}
  400176:	bc70      	pop	{r4, r5, r6}
  400178:	4770      	bx	lr
  40017a:	bf00      	nop
  40017c:	400e123c 	.word	0x400e123c
  400180:	200004c5 	.word	0x200004c5
  400184:	200004c4 	.word	0x200004c4
  400188:	400e1030 	.word	0x400e1030
  40018c:	400e1034 	.word	0x400e1034

00400190 <Encoder_init>:



void Encoder_init(){
  400190:	b470      	push	{r4, r5, r6}

	A_seq = 0;
  400192:	2300      	movs	r3, #0
  400194:	4aa8      	ldr	r2, [pc, #672]	; (400438 <Encoder_init+0x2a8>)
  400196:	7013      	strb	r3, [r2, #0]
	B_seq = 0;
  400198:	4aa8      	ldr	r2, [pc, #672]	; (40043c <Encoder_init+0x2ac>)
  40019a:	7013      	strb	r3, [r2, #0]

	//enable clock for PIOC
	REG_PMC_PCER0 |= PMC_PCER0_PID13;
  40019c:	4aa8      	ldr	r2, [pc, #672]	; (400440 <Encoder_init+0x2b0>)
  40019e:	6813      	ldr	r3, [r2, #0]
  4001a0:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
  4001a4:	6013      	str	r3, [r2, #0]


	/**************			CONFIGURE 16 STEP ENCODERS			**************/

	//Set up PC0 as ENCODER 1 INPUT A
	REG_PIOC_PER |= PIO_PER_P0; //enable PIO controller
  4001a6:	4da7      	ldr	r5, [pc, #668]	; (400444 <Encoder_init+0x2b4>)
  4001a8:	682b      	ldr	r3, [r5, #0]
  4001aa:	f043 0301 	orr.w	r3, r3, #1
  4001ae:	602b      	str	r3, [r5, #0]
	REG_PIOC_ODR |= PIO_ODR_P0; //disable output
  4001b0:	4ca5      	ldr	r4, [pc, #660]	; (400448 <Encoder_init+0x2b8>)
  4001b2:	6823      	ldr	r3, [r4, #0]
  4001b4:	f043 0301 	orr.w	r3, r3, #1
  4001b8:	6023      	str	r3, [r4, #0]
	REG_PIOC_PPDDR |= PIO_PPDDR_P0; //disable pull-down resistor
  4001ba:	48a4      	ldr	r0, [pc, #656]	; (40044c <Encoder_init+0x2bc>)
  4001bc:	6803      	ldr	r3, [r0, #0]
  4001be:	f043 0301 	orr.w	r3, r3, #1
  4001c2:	6003      	str	r3, [r0, #0]
	REG_PIOC_PUER |= PIO_PUER_P0;	//enable pull-up resistor
  4001c4:	49a2      	ldr	r1, [pc, #648]	; (400450 <Encoder_init+0x2c0>)
  4001c6:	680b      	ldr	r3, [r1, #0]
  4001c8:	f043 0301 	orr.w	r3, r3, #1
  4001cc:	600b      	str	r3, [r1, #0]
	REG_PIOC_IFSCER |= PIO_IFSCER_P0; //turn on slow clock debounce
  4001ce:	f602 6274 	addw	r2, r2, #3700	; 0xe74
  4001d2:	6813      	ldr	r3, [r2, #0]
  4001d4:	f043 0301 	orr.w	r3, r3, #1
  4001d8:	6013      	str	r3, [r2, #0]
	REG_PIOC_IFER |= PIO_IFER_P0;	//start debounce filter
  4001da:	4b9e      	ldr	r3, [pc, #632]	; (400454 <Encoder_init+0x2c4>)
  4001dc:	681e      	ldr	r6, [r3, #0]
  4001de:	f046 0601 	orr.w	r6, r6, #1
  4001e2:	601e      	str	r6, [r3, #0]

	//Set up PC1 as ENCODER 1 INPUT B
	REG_PIOC_PER |= PIO_PER_P1; //enable PIO controller
  4001e4:	682e      	ldr	r6, [r5, #0]
  4001e6:	f046 0602 	orr.w	r6, r6, #2
  4001ea:	602e      	str	r6, [r5, #0]
	REG_PIOC_ODR |= PIO_ODR_P1; //disable output
  4001ec:	6826      	ldr	r6, [r4, #0]
  4001ee:	f046 0602 	orr.w	r6, r6, #2
  4001f2:	6026      	str	r6, [r4, #0]
	REG_PIOC_PPDDR |= PIO_PPDDR_P1; //disable pull-down resistor
  4001f4:	6806      	ldr	r6, [r0, #0]
  4001f6:	f046 0602 	orr.w	r6, r6, #2
  4001fa:	6006      	str	r6, [r0, #0]
	REG_PIOC_PUER |= PIO_PUER_P1;	//enable pull-up resistor
  4001fc:	680e      	ldr	r6, [r1, #0]
  4001fe:	f046 0602 	orr.w	r6, r6, #2
  400202:	600e      	str	r6, [r1, #0]
	REG_PIOC_IFSCER |= PIO_IFSCER_P1; //turn on slow clock debounce
  400204:	6816      	ldr	r6, [r2, #0]
  400206:	f046 0602 	orr.w	r6, r6, #2
  40020a:	6016      	str	r6, [r2, #0]
	REG_PIOC_IFER |= PIO_IFER_P1;	//start debounce filter
  40020c:	681e      	ldr	r6, [r3, #0]
  40020e:	f046 0602 	orr.w	r6, r6, #2
  400212:	601e      	str	r6, [r3, #0]


	
	//Set up PC2 as ENCODER 2 INPUT A
	REG_PIOC_PER |= PIO_PER_P2; //enable PIO controller
  400214:	682e      	ldr	r6, [r5, #0]
  400216:	f046 0604 	orr.w	r6, r6, #4
  40021a:	602e      	str	r6, [r5, #0]
	REG_PIOC_ODR |= PIO_ODR_P2; //disable output
  40021c:	6826      	ldr	r6, [r4, #0]
  40021e:	f046 0604 	orr.w	r6, r6, #4
  400222:	6026      	str	r6, [r4, #0]
	REG_PIOC_PPDDR |= PIO_PPDDR_P2; //disable pull-down resistor
  400224:	6806      	ldr	r6, [r0, #0]
  400226:	f046 0604 	orr.w	r6, r6, #4
  40022a:	6006      	str	r6, [r0, #0]
	REG_PIOC_PUER |= PIO_PUER_P2;	//enable pull-up resistor
  40022c:	680e      	ldr	r6, [r1, #0]
  40022e:	f046 0604 	orr.w	r6, r6, #4
  400232:	600e      	str	r6, [r1, #0]
	REG_PIOC_IFSCER |= PIO_IFSCER_P2; //turn on slow clock debounce
  400234:	6816      	ldr	r6, [r2, #0]
  400236:	f046 0604 	orr.w	r6, r6, #4
  40023a:	6016      	str	r6, [r2, #0]
	REG_PIOC_IFER |= PIO_IFER_P2;	//start debounce filter
  40023c:	681e      	ldr	r6, [r3, #0]
  40023e:	f046 0604 	orr.w	r6, r6, #4
  400242:	601e      	str	r6, [r3, #0]

	//Set up PC3 as ENCODER 2 INPUT B
	REG_PIOC_PER |= PIO_PER_P3; //enable PIO controller
  400244:	682e      	ldr	r6, [r5, #0]
  400246:	f046 0608 	orr.w	r6, r6, #8
  40024a:	602e      	str	r6, [r5, #0]
	REG_PIOC_ODR |= PIO_ODR_P3; //disable output
  40024c:	6826      	ldr	r6, [r4, #0]
  40024e:	f046 0608 	orr.w	r6, r6, #8
  400252:	6026      	str	r6, [r4, #0]
	REG_PIOC_PPDDR |= PIO_PPDDR_P3; //disable pull-down resistor
  400254:	6806      	ldr	r6, [r0, #0]
  400256:	f046 0608 	orr.w	r6, r6, #8
  40025a:	6006      	str	r6, [r0, #0]
	REG_PIOC_PUER |= PIO_PUER_P3;	//enable pull-up resistor
  40025c:	680e      	ldr	r6, [r1, #0]
  40025e:	f046 0608 	orr.w	r6, r6, #8
  400262:	600e      	str	r6, [r1, #0]
	REG_PIOC_IFSCER |= PIO_IFSCER_P3; //turn on slow clock debounce
  400264:	6816      	ldr	r6, [r2, #0]
  400266:	f046 0608 	orr.w	r6, r6, #8
  40026a:	6016      	str	r6, [r2, #0]
	REG_PIOC_IFER |= PIO_IFER_P3;	//start debounce filter
  40026c:	681e      	ldr	r6, [r3, #0]
  40026e:	f046 0608 	orr.w	r6, r6, #8
  400272:	601e      	str	r6, [r3, #0]



	//Set up PC4 as ENCODER 3 INPUT A
	REG_PIOC_PER |= PIO_PER_P4; //enable PIO controller
  400274:	682e      	ldr	r6, [r5, #0]
  400276:	f046 0610 	orr.w	r6, r6, #16
  40027a:	602e      	str	r6, [r5, #0]
	REG_PIOC_ODR |= PIO_ODR_P4; //disable output
  40027c:	6826      	ldr	r6, [r4, #0]
  40027e:	f046 0610 	orr.w	r6, r6, #16
  400282:	6026      	str	r6, [r4, #0]
	REG_PIOC_PPDDR |= PIO_PPDDR_P4; //disable pull-down resistor
  400284:	6806      	ldr	r6, [r0, #0]
  400286:	f046 0610 	orr.w	r6, r6, #16
  40028a:	6006      	str	r6, [r0, #0]
	REG_PIOC_PUER |= PIO_PUER_P4;	//enable pull-up resistor
  40028c:	680e      	ldr	r6, [r1, #0]
  40028e:	f046 0610 	orr.w	r6, r6, #16
  400292:	600e      	str	r6, [r1, #0]
	REG_PIOC_IFSCER |= PIO_IFSCER_P4; //turn on slow clock debounce
  400294:	6816      	ldr	r6, [r2, #0]
  400296:	f046 0610 	orr.w	r6, r6, #16
  40029a:	6016      	str	r6, [r2, #0]
	REG_PIOC_IFER |= PIO_IFER_P4;	//start debounce filter
  40029c:	681e      	ldr	r6, [r3, #0]
  40029e:	f046 0610 	orr.w	r6, r6, #16
  4002a2:	601e      	str	r6, [r3, #0]

	//Set up PC5 as ENCODER 3 INPUT B
	REG_PIOC_PER |= PIO_PER_P5; //enable PIO controller
  4002a4:	682e      	ldr	r6, [r5, #0]
  4002a6:	f046 0620 	orr.w	r6, r6, #32
  4002aa:	602e      	str	r6, [r5, #0]
	REG_PIOC_ODR |= PIO_ODR_P5; //disable output
  4002ac:	6826      	ldr	r6, [r4, #0]
  4002ae:	f046 0620 	orr.w	r6, r6, #32
  4002b2:	6026      	str	r6, [r4, #0]
	REG_PIOC_PPDDR |= PIO_PPDDR_P5; //disable pull-down resistor
  4002b4:	6806      	ldr	r6, [r0, #0]
  4002b6:	f046 0620 	orr.w	r6, r6, #32
  4002ba:	6006      	str	r6, [r0, #0]
	REG_PIOC_PUER |= PIO_PUER_P5;	//enable pull-up resistor
  4002bc:	680e      	ldr	r6, [r1, #0]
  4002be:	f046 0620 	orr.w	r6, r6, #32
  4002c2:	600e      	str	r6, [r1, #0]
	REG_PIOC_IFSCER |= PIO_IFSCER_P5; //turn on slow clock debounce
  4002c4:	6816      	ldr	r6, [r2, #0]
  4002c6:	f046 0620 	orr.w	r6, r6, #32
  4002ca:	6016      	str	r6, [r2, #0]
	REG_PIOC_IFER |= PIO_IFER_P5;	//start debounce filter
  4002cc:	681e      	ldr	r6, [r3, #0]
  4002ce:	f046 0620 	orr.w	r6, r6, #32
  4002d2:	601e      	str	r6, [r3, #0]



	//Set up PC6 as ENCODER 4 INPUT A
	REG_PIOC_PER |= PIO_PER_P6; //enable PIO controller
  4002d4:	682e      	ldr	r6, [r5, #0]
  4002d6:	f046 0640 	orr.w	r6, r6, #64	; 0x40
  4002da:	602e      	str	r6, [r5, #0]
	REG_PIOC_ODR |= PIO_ODR_P6; //disable output
  4002dc:	6826      	ldr	r6, [r4, #0]
  4002de:	f046 0640 	orr.w	r6, r6, #64	; 0x40
  4002e2:	6026      	str	r6, [r4, #0]
	REG_PIOC_PPDDR |= PIO_PPDDR_P6; //disable pull-down resistor
  4002e4:	6806      	ldr	r6, [r0, #0]
  4002e6:	f046 0640 	orr.w	r6, r6, #64	; 0x40
  4002ea:	6006      	str	r6, [r0, #0]
	REG_PIOC_PUER |= PIO_PUER_P6;	//enable pull-up resistor
  4002ec:	680e      	ldr	r6, [r1, #0]
  4002ee:	f046 0640 	orr.w	r6, r6, #64	; 0x40
  4002f2:	600e      	str	r6, [r1, #0]
	REG_PIOC_IFSCER |= PIO_IFSCER_P6; //turn on slow clock debounce
  4002f4:	6816      	ldr	r6, [r2, #0]
  4002f6:	f046 0640 	orr.w	r6, r6, #64	; 0x40
  4002fa:	6016      	str	r6, [r2, #0]
	REG_PIOC_IFER |= PIO_IFER_P6;	//start debounce filter
  4002fc:	681e      	ldr	r6, [r3, #0]
  4002fe:	f046 0640 	orr.w	r6, r6, #64	; 0x40
  400302:	601e      	str	r6, [r3, #0]

	//Set up PC7 as ENCODER 4 INPUT B
	REG_PIOC_PER |= PIO_PER_P7; //enable PIO controller
  400304:	682e      	ldr	r6, [r5, #0]
  400306:	f046 0680 	orr.w	r6, r6, #128	; 0x80
  40030a:	602e      	str	r6, [r5, #0]
	REG_PIOC_ODR |= PIO_ODR_P7; //disable output
  40030c:	6826      	ldr	r6, [r4, #0]
  40030e:	f046 0680 	orr.w	r6, r6, #128	; 0x80
  400312:	6026      	str	r6, [r4, #0]
	REG_PIOC_PPDDR |= PIO_PPDDR_P7; //disable pull-down resistor
  400314:	6806      	ldr	r6, [r0, #0]
  400316:	f046 0680 	orr.w	r6, r6, #128	; 0x80
  40031a:	6006      	str	r6, [r0, #0]
	REG_PIOC_PUER |= PIO_PUER_P7;	//enable pull-up resistor
  40031c:	680e      	ldr	r6, [r1, #0]
  40031e:	f046 0680 	orr.w	r6, r6, #128	; 0x80
  400322:	600e      	str	r6, [r1, #0]
	REG_PIOC_IFSCER |= PIO_IFSCER_P7; //turn on slow clock debounce
  400324:	6816      	ldr	r6, [r2, #0]
  400326:	f046 0680 	orr.w	r6, r6, #128	; 0x80
  40032a:	6016      	str	r6, [r2, #0]
	REG_PIOC_IFER |= PIO_IFER_P7;	//start debounce filter
  40032c:	681e      	ldr	r6, [r3, #0]
  40032e:	f046 0680 	orr.w	r6, r6, #128	; 0x80
  400332:	601e      	str	r6, [r3, #0]



	//Set up PC8 as ENCODER 5 INPUT A
	REG_PIOC_PER |= PIO_PER_P8; //enable PIO controller
  400334:	682e      	ldr	r6, [r5, #0]
  400336:	f446 7680 	orr.w	r6, r6, #256	; 0x100
  40033a:	602e      	str	r6, [r5, #0]
	REG_PIOC_ODR |= PIO_ODR_P8; //disable output
  40033c:	6826      	ldr	r6, [r4, #0]
  40033e:	f446 7680 	orr.w	r6, r6, #256	; 0x100
  400342:	6026      	str	r6, [r4, #0]
	REG_PIOC_PPDDR |= PIO_PPDDR_P8; //disable pull-down resistor
  400344:	6806      	ldr	r6, [r0, #0]
  400346:	f446 7680 	orr.w	r6, r6, #256	; 0x100
  40034a:	6006      	str	r6, [r0, #0]
	REG_PIOC_PUER |= PIO_PUER_P8;	//enable pull-up resistor
  40034c:	680e      	ldr	r6, [r1, #0]
  40034e:	f446 7680 	orr.w	r6, r6, #256	; 0x100
  400352:	600e      	str	r6, [r1, #0]
	REG_PIOC_IFSCER |= PIO_IFSCER_P8; //turn on slow clock debounce
  400354:	6816      	ldr	r6, [r2, #0]
  400356:	f446 7680 	orr.w	r6, r6, #256	; 0x100
  40035a:	6016      	str	r6, [r2, #0]
	REG_PIOC_IFER |= PIO_IFER_P8;	//start debounce filter
  40035c:	681e      	ldr	r6, [r3, #0]
  40035e:	f446 7680 	orr.w	r6, r6, #256	; 0x100
  400362:	601e      	str	r6, [r3, #0]

	//Set up PC9 as ENCODER 5 INPUT B
	REG_PIOC_PER |= PIO_PER_P9; //enable PIO controller
  400364:	682e      	ldr	r6, [r5, #0]
  400366:	f446 7600 	orr.w	r6, r6, #512	; 0x200
  40036a:	602e      	str	r6, [r5, #0]
	REG_PIOC_ODR |= PIO_ODR_P9; //disable output
  40036c:	6826      	ldr	r6, [r4, #0]
  40036e:	f446 7600 	orr.w	r6, r6, #512	; 0x200
  400372:	6026      	str	r6, [r4, #0]
	REG_PIOC_PPDDR |= PIO_PPDDR_P9; //disable pull-down resistor
  400374:	6806      	ldr	r6, [r0, #0]
  400376:	f446 7600 	orr.w	r6, r6, #512	; 0x200
  40037a:	6006      	str	r6, [r0, #0]
	REG_PIOC_PUER |= PIO_PUER_P9;	//enable pull-up resistor
  40037c:	680e      	ldr	r6, [r1, #0]
  40037e:	f446 7600 	orr.w	r6, r6, #512	; 0x200
  400382:	600e      	str	r6, [r1, #0]
	REG_PIOC_IFSCER |= PIO_IFSCER_P9; //turn on slow clock debounce
  400384:	6816      	ldr	r6, [r2, #0]
  400386:	f446 7600 	orr.w	r6, r6, #512	; 0x200
  40038a:	6016      	str	r6, [r2, #0]
	REG_PIOC_IFER |= PIO_IFER_P9;	//start debounce filter
  40038c:	681e      	ldr	r6, [r3, #0]
  40038e:	f446 7600 	orr.w	r6, r6, #512	; 0x200
  400392:	601e      	str	r6, [r3, #0]



	//Set up PC10 as ENCODER 6 INPUT A
	REG_PIOC_PER |= PIO_PER_P10; //enable PIO controller
  400394:	682e      	ldr	r6, [r5, #0]
  400396:	f446 6680 	orr.w	r6, r6, #1024	; 0x400
  40039a:	602e      	str	r6, [r5, #0]
	REG_PIOC_ODR |= PIO_ODR_P10; //disable output
  40039c:	6826      	ldr	r6, [r4, #0]
  40039e:	f446 6680 	orr.w	r6, r6, #1024	; 0x400
  4003a2:	6026      	str	r6, [r4, #0]
	REG_PIOC_PPDDR |= PIO_PPDDR_P10; //disable pull-down resistor
  4003a4:	6806      	ldr	r6, [r0, #0]
  4003a6:	f446 6680 	orr.w	r6, r6, #1024	; 0x400
  4003aa:	6006      	str	r6, [r0, #0]
	REG_PIOC_PUER |= PIO_PUER_P10;	//enable pull-up resistor
  4003ac:	680e      	ldr	r6, [r1, #0]
  4003ae:	f446 6680 	orr.w	r6, r6, #1024	; 0x400
  4003b2:	600e      	str	r6, [r1, #0]
	REG_PIOC_IFSCER |= PIO_IFSCER_P10; //turn on slow clock debounce
  4003b4:	6816      	ldr	r6, [r2, #0]
  4003b6:	f446 6680 	orr.w	r6, r6, #1024	; 0x400
  4003ba:	6016      	str	r6, [r2, #0]
	REG_PIOC_IFER |= PIO_IFER_P10;	//start debounce filter
  4003bc:	681e      	ldr	r6, [r3, #0]
  4003be:	f446 6680 	orr.w	r6, r6, #1024	; 0x400
  4003c2:	601e      	str	r6, [r3, #0]

	//Set up PC11 as ENCODER 6 INPUT B
	REG_PIOC_PER |= PIO_PER_P11; //enable PIO controller
  4003c4:	682e      	ldr	r6, [r5, #0]
  4003c6:	f446 6600 	orr.w	r6, r6, #2048	; 0x800
  4003ca:	602e      	str	r6, [r5, #0]
	REG_PIOC_ODR |= PIO_ODR_P11; //disable output
  4003cc:	6826      	ldr	r6, [r4, #0]
  4003ce:	f446 6600 	orr.w	r6, r6, #2048	; 0x800
  4003d2:	6026      	str	r6, [r4, #0]
	REG_PIOC_PPDDR |= PIO_PPDDR_P11; //disable pull-down resistor
  4003d4:	6806      	ldr	r6, [r0, #0]
  4003d6:	f446 6600 	orr.w	r6, r6, #2048	; 0x800
  4003da:	6006      	str	r6, [r0, #0]
	REG_PIOC_PUER |= PIO_PUER_P11;	//enable pull-up resistor
  4003dc:	680e      	ldr	r6, [r1, #0]
  4003de:	f446 6600 	orr.w	r6, r6, #2048	; 0x800
  4003e2:	600e      	str	r6, [r1, #0]
	REG_PIOC_IFSCER |= PIO_IFSCER_P11; //turn on slow clock debounce
  4003e4:	6816      	ldr	r6, [r2, #0]
  4003e6:	f446 6600 	orr.w	r6, r6, #2048	; 0x800
  4003ea:	6016      	str	r6, [r2, #0]
	REG_PIOC_IFER |= PIO_IFER_P11;	//start debounce filter
  4003ec:	681e      	ldr	r6, [r3, #0]
  4003ee:	f446 6600 	orr.w	r6, r6, #2048	; 0x800
  4003f2:	601e      	str	r6, [r3, #0]



	//Set up PC12 as ENCODER 7 INPUT A
	REG_PIOC_PER |= PIO_PER_P3; //enable PIO controller
  4003f4:	682e      	ldr	r6, [r5, #0]
  4003f6:	f046 0608 	orr.w	r6, r6, #8
  4003fa:	602e      	str	r6, [r5, #0]
	REG_PIOC_ODR |= PIO_ODR_P3; //disable output
  4003fc:	6826      	ldr	r6, [r4, #0]
  4003fe:	f046 0608 	orr.w	r6, r6, #8
  400402:	6026      	str	r6, [r4, #0]
	REG_PIOC_PPDDR |= PIO_PPDDR_P3; //disable pull-down resistor
  400404:	6806      	ldr	r6, [r0, #0]
  400406:	f046 0608 	orr.w	r6, r6, #8
  40040a:	6006      	str	r6, [r0, #0]
	REG_PIOC_PUER |= PIO_PUER_P3;	//enable pull-up resistor
  40040c:	680e      	ldr	r6, [r1, #0]
  40040e:	f046 0608 	orr.w	r6, r6, #8
  400412:	600e      	str	r6, [r1, #0]
	REG_PIOC_IFSCER |= PIO_IFSCER_P3; //turn on slow clock debounce
  400414:	6816      	ldr	r6, [r2, #0]
  400416:	f046 0608 	orr.w	r6, r6, #8
  40041a:	6016      	str	r6, [r2, #0]
	REG_PIOC_IFER |= PIO_IFER_P3;	//start debounce filter
  40041c:	681e      	ldr	r6, [r3, #0]
  40041e:	f046 0608 	orr.w	r6, r6, #8
  400422:	601e      	str	r6, [r3, #0]

	//Set up PC13 as ENCODER 7 INPUT B
	REG_PIOC_PER |= PIO_PER_P13; //enable PIO controller
  400424:	682e      	ldr	r6, [r5, #0]
  400426:	f446 5600 	orr.w	r6, r6, #8192	; 0x2000
  40042a:	602e      	str	r6, [r5, #0]
	REG_PIOC_ODR |= PIO_ODR_P13; //disable output
  40042c:	6826      	ldr	r6, [r4, #0]
  40042e:	f446 5600 	orr.w	r6, r6, #8192	; 0x2000
  400432:	6026      	str	r6, [r4, #0]
	REG_PIOC_PPDDR |= PIO_PPDDR_P13; //disable pull-down resistor
  400434:	6806      	ldr	r6, [r0, #0]
  400436:	e00f      	b.n	400458 <Encoder_init+0x2c8>
  400438:	200004c4 	.word	0x200004c4
  40043c:	200004c5 	.word	0x200004c5
  400440:	400e0410 	.word	0x400e0410
  400444:	400e1200 	.word	0x400e1200
  400448:	400e1214 	.word	0x400e1214
  40044c:	400e1290 	.word	0x400e1290
  400450:	400e1264 	.word	0x400e1264
  400454:	400e1220 	.word	0x400e1220
  400458:	f446 5600 	orr.w	r6, r6, #8192	; 0x2000
  40045c:	6006      	str	r6, [r0, #0]
	REG_PIOC_PUER |= PIO_PUER_P13;	//enable pull-up resistor
  40045e:	680e      	ldr	r6, [r1, #0]
  400460:	f446 5600 	orr.w	r6, r6, #8192	; 0x2000
  400464:	600e      	str	r6, [r1, #0]
	REG_PIOC_IFSCER |= PIO_IFSCER_P13; //turn on slow clock debounce
  400466:	6816      	ldr	r6, [r2, #0]
  400468:	f446 5600 	orr.w	r6, r6, #8192	; 0x2000
  40046c:	6016      	str	r6, [r2, #0]
	REG_PIOC_IFER |= PIO_IFER_P13;	//start debounce filter
  40046e:	681e      	ldr	r6, [r3, #0]
  400470:	f446 5600 	orr.w	r6, r6, #8192	; 0x2000
  400474:	601e      	str	r6, [r3, #0]



	//Set up PC14 as ENCODER 8 INPUT A
	REG_PIOC_PER |= PIO_PER_P14; //enable PIO controller
  400476:	682e      	ldr	r6, [r5, #0]
  400478:	f446 4680 	orr.w	r6, r6, #16384	; 0x4000
  40047c:	602e      	str	r6, [r5, #0]
	REG_PIOC_ODR |= PIO_ODR_P14; //disable output
  40047e:	6826      	ldr	r6, [r4, #0]
  400480:	f446 4680 	orr.w	r6, r6, #16384	; 0x4000
  400484:	6026      	str	r6, [r4, #0]
	REG_PIOC_PPDDR |= PIO_PPDDR_P14; //disable pull-down resistor
  400486:	6806      	ldr	r6, [r0, #0]
  400488:	f446 4680 	orr.w	r6, r6, #16384	; 0x4000
  40048c:	6006      	str	r6, [r0, #0]
	REG_PIOC_PUER |= PIO_PUER_P14;	//enable pull-up resistor
  40048e:	680e      	ldr	r6, [r1, #0]
  400490:	f446 4680 	orr.w	r6, r6, #16384	; 0x4000
  400494:	600e      	str	r6, [r1, #0]
	REG_PIOC_IFSCER |= PIO_IFSCER_P14; //turn on slow clock debounce
  400496:	6816      	ldr	r6, [r2, #0]
  400498:	f446 4680 	orr.w	r6, r6, #16384	; 0x4000
  40049c:	6016      	str	r6, [r2, #0]
	REG_PIOC_IFER |= PIO_IFER_P14;	//start debounce filter
  40049e:	681e      	ldr	r6, [r3, #0]
  4004a0:	f446 4680 	orr.w	r6, r6, #16384	; 0x4000
  4004a4:	601e      	str	r6, [r3, #0]

	//Set up PC15 as ENCODER 8 INPUT B
	REG_PIOC_PER |= PIO_PER_P15; //enable PIO controller
  4004a6:	682e      	ldr	r6, [r5, #0]
  4004a8:	f446 4600 	orr.w	r6, r6, #32768	; 0x8000
  4004ac:	602e      	str	r6, [r5, #0]
	REG_PIOC_ODR |= PIO_ODR_P15; //disable output
  4004ae:	6826      	ldr	r6, [r4, #0]
  4004b0:	f446 4600 	orr.w	r6, r6, #32768	; 0x8000
  4004b4:	6026      	str	r6, [r4, #0]
	REG_PIOC_PPDDR |= PIO_PPDDR_P15; //disable pull-down resistor
  4004b6:	6806      	ldr	r6, [r0, #0]
  4004b8:	f446 4600 	orr.w	r6, r6, #32768	; 0x8000
  4004bc:	6006      	str	r6, [r0, #0]
	REG_PIOC_PUER |= PIO_PUER_P15;	//enable pull-up resistor
  4004be:	680e      	ldr	r6, [r1, #0]
  4004c0:	f446 4600 	orr.w	r6, r6, #32768	; 0x8000
  4004c4:	600e      	str	r6, [r1, #0]
	REG_PIOC_IFSCER |= PIO_IFSCER_P15; //turn on slow clock debounce
  4004c6:	6816      	ldr	r6, [r2, #0]
  4004c8:	f446 4600 	orr.w	r6, r6, #32768	; 0x8000
  4004cc:	6016      	str	r6, [r2, #0]
	REG_PIOC_IFER |= PIO_IFER_P15;	//start debounce filter
  4004ce:	681e      	ldr	r6, [r3, #0]
  4004d0:	f446 4600 	orr.w	r6, r6, #32768	; 0x8000
  4004d4:	601e      	str	r6, [r3, #0]



	//Set up PC16 as ENCODER 9 INPUT A
	REG_PIOC_PER |= PIO_PER_P16; //enable PIO controller
  4004d6:	682e      	ldr	r6, [r5, #0]
  4004d8:	f446 3680 	orr.w	r6, r6, #65536	; 0x10000
  4004dc:	602e      	str	r6, [r5, #0]
	REG_PIOC_ODR |= PIO_ODR_P16; //disable output
  4004de:	6826      	ldr	r6, [r4, #0]
  4004e0:	f446 3680 	orr.w	r6, r6, #65536	; 0x10000
  4004e4:	6026      	str	r6, [r4, #0]
	REG_PIOC_PPDDR |= PIO_PPDDR_P16; //disable pull-down resistor
  4004e6:	6806      	ldr	r6, [r0, #0]
  4004e8:	f446 3680 	orr.w	r6, r6, #65536	; 0x10000
  4004ec:	6006      	str	r6, [r0, #0]
	REG_PIOC_PUER |= PIO_PUER_P16;	//enable pull-up resistor
  4004ee:	680e      	ldr	r6, [r1, #0]
  4004f0:	f446 3680 	orr.w	r6, r6, #65536	; 0x10000
  4004f4:	600e      	str	r6, [r1, #0]
	REG_PIOC_IFSCER |= PIO_IFSCER_P16; //turn on slow clock debounce
  4004f6:	6816      	ldr	r6, [r2, #0]
  4004f8:	f446 3680 	orr.w	r6, r6, #65536	; 0x10000
  4004fc:	6016      	str	r6, [r2, #0]
	REG_PIOC_IFER |= PIO_IFER_P16;	//start debounce filter
  4004fe:	681e      	ldr	r6, [r3, #0]
  400500:	f446 3680 	orr.w	r6, r6, #65536	; 0x10000
  400504:	601e      	str	r6, [r3, #0]

	//Set up PC17 as ENCODER 9 INPUT B
	REG_PIOC_PER |= PIO_PER_P17; //enable PIO controller
  400506:	682e      	ldr	r6, [r5, #0]
  400508:	f446 3600 	orr.w	r6, r6, #131072	; 0x20000
  40050c:	602e      	str	r6, [r5, #0]
	REG_PIOC_ODR |= PIO_ODR_P17; //disable output
  40050e:	6826      	ldr	r6, [r4, #0]
  400510:	f446 3600 	orr.w	r6, r6, #131072	; 0x20000
  400514:	6026      	str	r6, [r4, #0]
	REG_PIOC_PPDDR |= PIO_PPDDR_P17; //disable pull-down resistor
  400516:	6806      	ldr	r6, [r0, #0]
  400518:	f446 3600 	orr.w	r6, r6, #131072	; 0x20000
  40051c:	6006      	str	r6, [r0, #0]
	REG_PIOC_PUER |= PIO_PUER_P17;	//enable pull-up resistor
  40051e:	680e      	ldr	r6, [r1, #0]
  400520:	f446 3600 	orr.w	r6, r6, #131072	; 0x20000
  400524:	600e      	str	r6, [r1, #0]
	REG_PIOC_IFSCER |= PIO_IFSCER_P17; //turn on slow clock debounce
  400526:	6816      	ldr	r6, [r2, #0]
  400528:	f446 3600 	orr.w	r6, r6, #131072	; 0x20000
  40052c:	6016      	str	r6, [r2, #0]
	REG_PIOC_IFER |= PIO_IFER_P17;	//start debounce filter
  40052e:	681e      	ldr	r6, [r3, #0]
  400530:	f446 3600 	orr.w	r6, r6, #131072	; 0x20000
  400534:	601e      	str	r6, [r3, #0]



	
	//Set up PC18 as ENCODER 10 INPUT A
	REG_PIOC_PER |= PIO_PER_P18; //enable PIO controller
  400536:	682e      	ldr	r6, [r5, #0]
  400538:	f446 2680 	orr.w	r6, r6, #262144	; 0x40000
  40053c:	602e      	str	r6, [r5, #0]
	REG_PIOC_ODR |= PIO_ODR_P18; //disable output
  40053e:	6826      	ldr	r6, [r4, #0]
  400540:	f446 2680 	orr.w	r6, r6, #262144	; 0x40000
  400544:	6026      	str	r6, [r4, #0]
	REG_PIOC_PPDDR |= PIO_PPDDR_P18; //disable pull-down resistor
  400546:	6806      	ldr	r6, [r0, #0]
  400548:	f446 2680 	orr.w	r6, r6, #262144	; 0x40000
  40054c:	6006      	str	r6, [r0, #0]
	REG_PIOC_PUER |= PIO_PUER_P18;	//enable pull-up resistor
  40054e:	680e      	ldr	r6, [r1, #0]
  400550:	f446 2680 	orr.w	r6, r6, #262144	; 0x40000
  400554:	600e      	str	r6, [r1, #0]
	REG_PIOC_IFSCER |= PIO_IFSCER_P18; //turn on slow clock debounce
  400556:	6816      	ldr	r6, [r2, #0]
  400558:	f446 2680 	orr.w	r6, r6, #262144	; 0x40000
  40055c:	6016      	str	r6, [r2, #0]
	REG_PIOC_IFER |= PIO_IFER_P18;	//start debounce filter
  40055e:	681e      	ldr	r6, [r3, #0]
  400560:	f446 2680 	orr.w	r6, r6, #262144	; 0x40000
  400564:	601e      	str	r6, [r3, #0]

	//Set up PC19 as ENCODER 10 INPUT B
	REG_PIOC_PER |= PIO_PER_P19; //enable PIO controller
  400566:	682e      	ldr	r6, [r5, #0]
  400568:	f446 2600 	orr.w	r6, r6, #524288	; 0x80000
  40056c:	602e      	str	r6, [r5, #0]
	REG_PIOC_ODR |= PIO_ODR_P19; //disable output
  40056e:	6826      	ldr	r6, [r4, #0]
  400570:	f446 2600 	orr.w	r6, r6, #524288	; 0x80000
  400574:	6026      	str	r6, [r4, #0]
	REG_PIOC_PPDDR |= PIO_PPDDR_P19; //disable pull-down resistor
  400576:	6806      	ldr	r6, [r0, #0]
  400578:	f446 2600 	orr.w	r6, r6, #524288	; 0x80000
  40057c:	6006      	str	r6, [r0, #0]
	REG_PIOC_PUER |= PIO_PUER_P19;	//enable pull-up resistor
  40057e:	680e      	ldr	r6, [r1, #0]
  400580:	f446 2600 	orr.w	r6, r6, #524288	; 0x80000
  400584:	600e      	str	r6, [r1, #0]
	REG_PIOC_IFSCER |= PIO_IFSCER_P19; //turn on slow clock debounce
  400586:	6816      	ldr	r6, [r2, #0]
  400588:	f446 2600 	orr.w	r6, r6, #524288	; 0x80000
  40058c:	6016      	str	r6, [r2, #0]
	REG_PIOC_IFER |= PIO_IFER_P19;	//start debounce filter
  40058e:	681e      	ldr	r6, [r3, #0]
  400590:	f446 2600 	orr.w	r6, r6, #524288	; 0x80000
  400594:	601e      	str	r6, [r3, #0]



	//Set up PC20 as ENCODER 11 INPUT A
	REG_PIOC_PER |= PIO_PER_P20; //enable PIO controller
  400596:	682e      	ldr	r6, [r5, #0]
  400598:	f446 1680 	orr.w	r6, r6, #1048576	; 0x100000
  40059c:	602e      	str	r6, [r5, #0]
	REG_PIOC_ODR |= PIO_ODR_P20; //disable output
  40059e:	6826      	ldr	r6, [r4, #0]
  4005a0:	f446 1680 	orr.w	r6, r6, #1048576	; 0x100000
  4005a4:	6026      	str	r6, [r4, #0]
	REG_PIOC_PPDDR |= PIO_PPDDR_P20; //disable pull-down resistor
  4005a6:	6806      	ldr	r6, [r0, #0]
  4005a8:	f446 1680 	orr.w	r6, r6, #1048576	; 0x100000
  4005ac:	6006      	str	r6, [r0, #0]
	REG_PIOC_PUER |= PIO_PUER_P20;	//enable pull-up resistor
  4005ae:	680e      	ldr	r6, [r1, #0]
  4005b0:	f446 1680 	orr.w	r6, r6, #1048576	; 0x100000
  4005b4:	600e      	str	r6, [r1, #0]
	REG_PIOC_IFSCER |= PIO_IFSCER_P20; //turn on slow clock debounce
  4005b6:	6816      	ldr	r6, [r2, #0]
  4005b8:	f446 1680 	orr.w	r6, r6, #1048576	; 0x100000
  4005bc:	6016      	str	r6, [r2, #0]
	REG_PIOC_IFER |= PIO_IFER_P20;	//start debounce filter
  4005be:	681e      	ldr	r6, [r3, #0]
  4005c0:	f446 1680 	orr.w	r6, r6, #1048576	; 0x100000
  4005c4:	601e      	str	r6, [r3, #0]

	//Set up PC21 as ENCODER 11 INPUT B
	REG_PIOC_PER |= PIO_PER_P21; //enable PIO controller
  4005c6:	682e      	ldr	r6, [r5, #0]
  4005c8:	f446 1600 	orr.w	r6, r6, #2097152	; 0x200000
  4005cc:	602e      	str	r6, [r5, #0]
	REG_PIOC_ODR |= PIO_ODR_P21; //disable output
  4005ce:	6826      	ldr	r6, [r4, #0]
  4005d0:	f446 1600 	orr.w	r6, r6, #2097152	; 0x200000
  4005d4:	6026      	str	r6, [r4, #0]
	REG_PIOC_PPDDR |= PIO_PPDDR_P21; //disable pull-down resistor
  4005d6:	6806      	ldr	r6, [r0, #0]
  4005d8:	f446 1600 	orr.w	r6, r6, #2097152	; 0x200000
  4005dc:	6006      	str	r6, [r0, #0]
	REG_PIOC_PUER |= PIO_PUER_P21;	//enable pull-up resistor
  4005de:	680e      	ldr	r6, [r1, #0]
  4005e0:	f446 1600 	orr.w	r6, r6, #2097152	; 0x200000
  4005e4:	600e      	str	r6, [r1, #0]
	REG_PIOC_IFSCER |= PIO_IFSCER_P21; //turn on slow clock debounce
  4005e6:	6816      	ldr	r6, [r2, #0]
  4005e8:	f446 1600 	orr.w	r6, r6, #2097152	; 0x200000
  4005ec:	6016      	str	r6, [r2, #0]
	REG_PIOC_IFER |= PIO_IFER_P21;	//start debounce filter
  4005ee:	681e      	ldr	r6, [r3, #0]
  4005f0:	f446 1600 	orr.w	r6, r6, #2097152	; 0x200000
  4005f4:	601e      	str	r6, [r3, #0]



	//Set up PC22 as ENCODER 12 INPUT A
	REG_PIOC_PER |= PIO_PER_P22; //enable PIO controller
  4005f6:	682e      	ldr	r6, [r5, #0]
  4005f8:	f446 0680 	orr.w	r6, r6, #4194304	; 0x400000
  4005fc:	602e      	str	r6, [r5, #0]
	REG_PIOC_ODR |= PIO_ODR_P22; //disable output
  4005fe:	6826      	ldr	r6, [r4, #0]
  400600:	f446 0680 	orr.w	r6, r6, #4194304	; 0x400000
  400604:	6026      	str	r6, [r4, #0]
	REG_PIOC_PPDDR |= PIO_PPDDR_P22; //disable pull-down resistor
  400606:	6806      	ldr	r6, [r0, #0]
  400608:	f446 0680 	orr.w	r6, r6, #4194304	; 0x400000
  40060c:	6006      	str	r6, [r0, #0]
	REG_PIOC_PUER |= PIO_PUER_P22;	//enable pull-up resistor
  40060e:	680e      	ldr	r6, [r1, #0]
  400610:	f446 0680 	orr.w	r6, r6, #4194304	; 0x400000
  400614:	600e      	str	r6, [r1, #0]
	REG_PIOC_IFSCER |= PIO_IFSCER_P22; //turn on slow clock debounce
  400616:	6816      	ldr	r6, [r2, #0]
  400618:	f446 0680 	orr.w	r6, r6, #4194304	; 0x400000
  40061c:	6016      	str	r6, [r2, #0]
	REG_PIOC_IFER |= PIO_IFER_P22;	//start debounce filter
  40061e:	681e      	ldr	r6, [r3, #0]
  400620:	f446 0680 	orr.w	r6, r6, #4194304	; 0x400000
  400624:	601e      	str	r6, [r3, #0]

	//Set up PC23 as ENCODER 12 INPUT B
	REG_PIOC_PER |= PIO_PER_P23; //enable PIO controller
  400626:	682e      	ldr	r6, [r5, #0]
  400628:	f446 0600 	orr.w	r6, r6, #8388608	; 0x800000
  40062c:	602e      	str	r6, [r5, #0]
	REG_PIOC_ODR |= PIO_ODR_P23; //disable output
  40062e:	6826      	ldr	r6, [r4, #0]
  400630:	f446 0600 	orr.w	r6, r6, #8388608	; 0x800000
  400634:	6026      	str	r6, [r4, #0]
	REG_PIOC_PPDDR |= PIO_PPDDR_P23; //disable pull-down resistor
  400636:	6806      	ldr	r6, [r0, #0]
  400638:	f446 0600 	orr.w	r6, r6, #8388608	; 0x800000
  40063c:	6006      	str	r6, [r0, #0]
	REG_PIOC_PUER |= PIO_PUER_P23;	//enable pull-up resistor
  40063e:	680e      	ldr	r6, [r1, #0]
  400640:	f446 0600 	orr.w	r6, r6, #8388608	; 0x800000
  400644:	600e      	str	r6, [r1, #0]
	REG_PIOC_IFSCER |= PIO_IFSCER_P23; //turn on slow clock debounce
  400646:	6816      	ldr	r6, [r2, #0]
  400648:	f446 0600 	orr.w	r6, r6, #8388608	; 0x800000
  40064c:	6016      	str	r6, [r2, #0]
	REG_PIOC_IFER |= PIO_IFER_P23;	//start debounce filter
  40064e:	681e      	ldr	r6, [r3, #0]
  400650:	f446 0600 	orr.w	r6, r6, #8388608	; 0x800000
  400654:	601e      	str	r6, [r3, #0]



	//Set up PC24 as ENCODER 13 INPUT A
	REG_PIOC_PER |= PIO_PER_P24; //enable PIO controller
  400656:	682e      	ldr	r6, [r5, #0]
  400658:	f046 7680 	orr.w	r6, r6, #16777216	; 0x1000000
  40065c:	602e      	str	r6, [r5, #0]
	REG_PIOC_ODR |= PIO_ODR_P24; //disable output
  40065e:	6826      	ldr	r6, [r4, #0]
  400660:	f046 7680 	orr.w	r6, r6, #16777216	; 0x1000000
  400664:	6026      	str	r6, [r4, #0]
	REG_PIOC_PPDDR |= PIO_PPDDR_P24; //disable pull-down resistor
  400666:	6806      	ldr	r6, [r0, #0]
  400668:	f046 7680 	orr.w	r6, r6, #16777216	; 0x1000000
  40066c:	6006      	str	r6, [r0, #0]
	REG_PIOC_PUER |= PIO_PUER_P24;	//enable pull-up resistor
  40066e:	680e      	ldr	r6, [r1, #0]
  400670:	f046 7680 	orr.w	r6, r6, #16777216	; 0x1000000
  400674:	600e      	str	r6, [r1, #0]
	REG_PIOC_IFSCER |= PIO_IFSCER_P24; //turn on slow clock debounce
  400676:	6816      	ldr	r6, [r2, #0]
  400678:	f046 7680 	orr.w	r6, r6, #16777216	; 0x1000000
  40067c:	6016      	str	r6, [r2, #0]
	REG_PIOC_IFER |= PIO_IFER_P24;	//start debounce filter
  40067e:	681e      	ldr	r6, [r3, #0]
  400680:	f046 7680 	orr.w	r6, r6, #16777216	; 0x1000000
  400684:	601e      	str	r6, [r3, #0]

	//Set up PC25 as ENCODER 13 INPUT B
	REG_PIOC_PER |= PIO_PER_P25; //enable PIO controller
  400686:	682e      	ldr	r6, [r5, #0]
  400688:	f046 7600 	orr.w	r6, r6, #33554432	; 0x2000000
  40068c:	602e      	str	r6, [r5, #0]
	REG_PIOC_ODR |= PIO_ODR_P25; //disable output
  40068e:	6826      	ldr	r6, [r4, #0]
  400690:	f046 7600 	orr.w	r6, r6, #33554432	; 0x2000000
  400694:	6026      	str	r6, [r4, #0]
	REG_PIOC_PPDDR |= PIO_PPDDR_P25; //disable pull-down resistor
  400696:	6806      	ldr	r6, [r0, #0]
  400698:	f046 7600 	orr.w	r6, r6, #33554432	; 0x2000000
  40069c:	6006      	str	r6, [r0, #0]
	REG_PIOC_PUER |= PIO_PUER_P25;	//enable pull-up resistor
  40069e:	680e      	ldr	r6, [r1, #0]
  4006a0:	f046 7600 	orr.w	r6, r6, #33554432	; 0x2000000
  4006a4:	600e      	str	r6, [r1, #0]
	REG_PIOC_IFSCER |= PIO_IFSCER_P25; //turn on slow clock debounce
  4006a6:	6816      	ldr	r6, [r2, #0]
  4006a8:	f046 7600 	orr.w	r6, r6, #33554432	; 0x2000000
  4006ac:	6016      	str	r6, [r2, #0]
	REG_PIOC_IFER |= PIO_IFER_P25;	//start debounce filter
  4006ae:	681e      	ldr	r6, [r3, #0]
  4006b0:	f046 7600 	orr.w	r6, r6, #33554432	; 0x2000000
  4006b4:	601e      	str	r6, [r3, #0]



	//Set up PC26 as ENCODER 14 INPUT A
	REG_PIOC_PER |= PIO_PER_P26; //enable PIO controller
  4006b6:	682e      	ldr	r6, [r5, #0]
  4006b8:	f046 6680 	orr.w	r6, r6, #67108864	; 0x4000000
  4006bc:	602e      	str	r6, [r5, #0]
	REG_PIOC_ODR |= PIO_ODR_P26; //disable output
  4006be:	6826      	ldr	r6, [r4, #0]
  4006c0:	f046 6680 	orr.w	r6, r6, #67108864	; 0x4000000
  4006c4:	6026      	str	r6, [r4, #0]
	REG_PIOC_PPDDR |= PIO_PPDDR_P26; //disable pull-down resistor
  4006c6:	6806      	ldr	r6, [r0, #0]
  4006c8:	f046 6680 	orr.w	r6, r6, #67108864	; 0x4000000
  4006cc:	6006      	str	r6, [r0, #0]
	REG_PIOC_PUER |= PIO_PUER_P26;	//enable pull-up resistor
  4006ce:	680e      	ldr	r6, [r1, #0]
  4006d0:	f046 6680 	orr.w	r6, r6, #67108864	; 0x4000000
  4006d4:	600e      	str	r6, [r1, #0]
	REG_PIOC_IFSCER |= PIO_IFSCER_P26; //turn on slow clock debounce
  4006d6:	6816      	ldr	r6, [r2, #0]
  4006d8:	f046 6680 	orr.w	r6, r6, #67108864	; 0x4000000
  4006dc:	6016      	str	r6, [r2, #0]
	REG_PIOC_IFER |= PIO_IFER_P26;	//start debounce filter
  4006de:	681e      	ldr	r6, [r3, #0]
  4006e0:	f046 6680 	orr.w	r6, r6, #67108864	; 0x4000000
  4006e4:	601e      	str	r6, [r3, #0]

	//Set up PC27 as ENCODER 14 INPUT B
	REG_PIOC_PER |= PIO_PER_P27; //enable PIO controller
  4006e6:	682e      	ldr	r6, [r5, #0]
  4006e8:	f046 6600 	orr.w	r6, r6, #134217728	; 0x8000000
  4006ec:	602e      	str	r6, [r5, #0]
	REG_PIOC_ODR |= PIO_ODR_P27; //disable output
  4006ee:	6826      	ldr	r6, [r4, #0]
  4006f0:	f046 6600 	orr.w	r6, r6, #134217728	; 0x8000000
  4006f4:	6026      	str	r6, [r4, #0]
	REG_PIOC_PPDDR |= PIO_PPDDR_P27; //disable pull-down resistor
  4006f6:	6806      	ldr	r6, [r0, #0]
  4006f8:	f046 6600 	orr.w	r6, r6, #134217728	; 0x8000000
  4006fc:	6006      	str	r6, [r0, #0]
	REG_PIOC_PUER |= PIO_PUER_P27;	//enable pull-up resistor
  4006fe:	680e      	ldr	r6, [r1, #0]
  400700:	f046 6600 	orr.w	r6, r6, #134217728	; 0x8000000
  400704:	600e      	str	r6, [r1, #0]
	REG_PIOC_IFSCER |= PIO_IFSCER_P27; //turn on slow clock debounce
  400706:	6816      	ldr	r6, [r2, #0]
  400708:	f046 6600 	orr.w	r6, r6, #134217728	; 0x8000000
  40070c:	6016      	str	r6, [r2, #0]
	REG_PIOC_IFER |= PIO_IFER_P27;	//start debounce filter
  40070e:	681e      	ldr	r6, [r3, #0]
  400710:	f046 6600 	orr.w	r6, r6, #134217728	; 0x8000000
  400714:	601e      	str	r6, [r3, #0]



	//Set up PC28 as ENCODER 15 INPUT A
	REG_PIOC_PER |= PIO_PER_P28; //enable PIO controller
  400716:	682e      	ldr	r6, [r5, #0]
  400718:	f046 5680 	orr.w	r6, r6, #268435456	; 0x10000000
  40071c:	602e      	str	r6, [r5, #0]
	REG_PIOC_ODR |= PIO_ODR_P28; //disable output
  40071e:	6826      	ldr	r6, [r4, #0]
  400720:	f046 5680 	orr.w	r6, r6, #268435456	; 0x10000000
  400724:	6026      	str	r6, [r4, #0]
	REG_PIOC_PPDDR |= PIO_PPDDR_P28; //disable pull-down resistor
  400726:	6806      	ldr	r6, [r0, #0]
  400728:	f046 5680 	orr.w	r6, r6, #268435456	; 0x10000000
  40072c:	6006      	str	r6, [r0, #0]
	REG_PIOC_PUER |= PIO_PUER_P28;	//enable pull-up resistor
  40072e:	680e      	ldr	r6, [r1, #0]
  400730:	f046 5680 	orr.w	r6, r6, #268435456	; 0x10000000
  400734:	600e      	str	r6, [r1, #0]
	REG_PIOC_IFSCER |= PIO_IFSCER_P28; //turn on slow clock debounce
  400736:	6816      	ldr	r6, [r2, #0]
  400738:	f046 5680 	orr.w	r6, r6, #268435456	; 0x10000000
  40073c:	6016      	str	r6, [r2, #0]
	REG_PIOC_IFER |= PIO_IFER_P28;	//start debounce filter
  40073e:	681e      	ldr	r6, [r3, #0]
  400740:	f046 5680 	orr.w	r6, r6, #268435456	; 0x10000000
  400744:	601e      	str	r6, [r3, #0]

	//Set up PC29 as ENCODER 15 INPUT B
	REG_PIOC_PER |= PIO_PER_P29; //enable PIO controller
  400746:	682e      	ldr	r6, [r5, #0]
  400748:	f046 5600 	orr.w	r6, r6, #536870912	; 0x20000000
  40074c:	602e      	str	r6, [r5, #0]
	REG_PIOC_ODR |= PIO_ODR_P29; //disable output
  40074e:	6826      	ldr	r6, [r4, #0]
  400750:	f046 5600 	orr.w	r6, r6, #536870912	; 0x20000000
  400754:	6026      	str	r6, [r4, #0]
	REG_PIOC_PPDDR |= PIO_PPDDR_P29; //disable pull-down resistor
  400756:	6806      	ldr	r6, [r0, #0]
  400758:	f046 5600 	orr.w	r6, r6, #536870912	; 0x20000000
  40075c:	6006      	str	r6, [r0, #0]
	REG_PIOC_PUER |= PIO_PUER_P29;	//enable pull-up resistor
  40075e:	680e      	ldr	r6, [r1, #0]
  400760:	f046 5600 	orr.w	r6, r6, #536870912	; 0x20000000
  400764:	600e      	str	r6, [r1, #0]
	REG_PIOC_IFSCER |= PIO_IFSCER_P29; //turn on slow clock debounce
  400766:	6816      	ldr	r6, [r2, #0]
  400768:	f046 5600 	orr.w	r6, r6, #536870912	; 0x20000000
  40076c:	6016      	str	r6, [r2, #0]
	REG_PIOC_IFER |= PIO_IFER_P29;	//start debounce filter
  40076e:	681e      	ldr	r6, [r3, #0]
  400770:	f046 5600 	orr.w	r6, r6, #536870912	; 0x20000000
  400774:	601e      	str	r6, [r3, #0]



	//Set up PC30 as ENCODER 16 INPUT A
	REG_PIOC_PER |= PIO_PER_P30; //enable PIO controller
  400776:	682e      	ldr	r6, [r5, #0]
  400778:	f046 4680 	orr.w	r6, r6, #1073741824	; 0x40000000
  40077c:	602e      	str	r6, [r5, #0]
	REG_PIOC_ODR |= PIO_ODR_P30; //disable output
  40077e:	6826      	ldr	r6, [r4, #0]
  400780:	f046 4680 	orr.w	r6, r6, #1073741824	; 0x40000000
  400784:	6026      	str	r6, [r4, #0]
	REG_PIOC_PPDDR |= PIO_PPDDR_P30; //disable pull-down resistor
  400786:	6806      	ldr	r6, [r0, #0]
  400788:	f046 4680 	orr.w	r6, r6, #1073741824	; 0x40000000
  40078c:	6006      	str	r6, [r0, #0]
	REG_PIOC_PUER |= PIO_PUER_P30;	//enable pull-up resistor
  40078e:	680e      	ldr	r6, [r1, #0]
  400790:	f046 4680 	orr.w	r6, r6, #1073741824	; 0x40000000
  400794:	600e      	str	r6, [r1, #0]
	REG_PIOC_IFSCER |= PIO_IFSCER_P30; //turn on slow clock debounce
  400796:	6816      	ldr	r6, [r2, #0]
  400798:	f046 4680 	orr.w	r6, r6, #1073741824	; 0x40000000
  40079c:	6016      	str	r6, [r2, #0]
	REG_PIOC_IFER |= PIO_IFER_P30;	//start debounce filter
  40079e:	681e      	ldr	r6, [r3, #0]
  4007a0:	f046 4680 	orr.w	r6, r6, #1073741824	; 0x40000000
  4007a4:	601e      	str	r6, [r3, #0]

	//Set up PC31 as ENCODER 16 INPUT B
	REG_PIOC_PER |= PIO_PER_P31; //enable PIO controller
  4007a6:	682e      	ldr	r6, [r5, #0]
  4007a8:	f046 4600 	orr.w	r6, r6, #2147483648	; 0x80000000
  4007ac:	602e      	str	r6, [r5, #0]
	REG_PIOC_ODR |= PIO_ODR_P31; //disable output
  4007ae:	6825      	ldr	r5, [r4, #0]
  4007b0:	f045 4500 	orr.w	r5, r5, #2147483648	; 0x80000000
  4007b4:	6025      	str	r5, [r4, #0]
	REG_PIOC_PPDDR |= PIO_PPDDR_P31; //disable pull-down resistor
  4007b6:	6804      	ldr	r4, [r0, #0]
  4007b8:	f044 4400 	orr.w	r4, r4, #2147483648	; 0x80000000
  4007bc:	6004      	str	r4, [r0, #0]
	REG_PIOC_PUER |= PIO_PUER_P31;	//enable pull-up resistor
  4007be:	6808      	ldr	r0, [r1, #0]
  4007c0:	f040 4000 	orr.w	r0, r0, #2147483648	; 0x80000000
  4007c4:	6008      	str	r0, [r1, #0]
	REG_PIOC_IFSCER |= PIO_IFSCER_P31; //turn on slow clock debounce
  4007c6:	6811      	ldr	r1, [r2, #0]
  4007c8:	f041 4100 	orr.w	r1, r1, #2147483648	; 0x80000000
  4007cc:	6011      	str	r1, [r2, #0]
	REG_PIOC_IFER |= PIO_IFER_P31;	//start debounce filter
  4007ce:	681a      	ldr	r2, [r3, #0]
  4007d0:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
  4007d4:	601a      	str	r2, [r3, #0]
	 


	/**************			CONFIGURE ENCODER INTERRUPTS			**************/

	uint32_t flag_clear = REG_PIOC_ISR;	//clear left over interrupt flags
  4007d6:	332c      	adds	r3, #44	; 0x2c
  4007d8:	681b      	ldr	r3, [r3, #0]

	//Enable interrupts for Encoder 1
	REG_PIOC_IER |= PIO_IER_P0;			//enable input rising edge interrupt
  4007da:	4b85      	ldr	r3, [pc, #532]	; (4009f0 <Encoder_init+0x860>)
  4007dc:	681a      	ldr	r2, [r3, #0]
  4007de:	f042 0201 	orr.w	r2, r2, #1
  4007e2:	601a      	str	r2, [r3, #0]
	REG_PIOC_REHLSR |= PIO_REHLSR_P0;
  4007e4:	4a83      	ldr	r2, [pc, #524]	; (4009f4 <Encoder_init+0x864>)
  4007e6:	6811      	ldr	r1, [r2, #0]
  4007e8:	f041 0101 	orr.w	r1, r1, #1
  4007ec:	6011      	str	r1, [r2, #0]
	REG_PIOC_IER |= PIO_IER_P1;			//enable input rising edge interrupt
  4007ee:	6819      	ldr	r1, [r3, #0]
  4007f0:	f041 0102 	orr.w	r1, r1, #2
  4007f4:	6019      	str	r1, [r3, #0]
	REG_PIOC_REHLSR |= PIO_REHLSR_P1;
  4007f6:	6811      	ldr	r1, [r2, #0]
  4007f8:	f041 0102 	orr.w	r1, r1, #2
  4007fc:	6011      	str	r1, [r2, #0]

	//Enable interrupts for Encoder 2
	REG_PIOC_IER |= PIO_IER_P2;			//enable input rising edge interrupt
  4007fe:	6819      	ldr	r1, [r3, #0]
  400800:	f041 0104 	orr.w	r1, r1, #4
  400804:	6019      	str	r1, [r3, #0]
	REG_PIOC_REHLSR |= PIO_REHLSR_P2;
  400806:	6812      	ldr	r2, [r2, #0]
  400808:	f042 0204 	orr.w	r2, r2, #4
  40080c:	3394      	adds	r3, #148	; 0x94
  40080e:	601a      	str	r2, [r3, #0]
	REG_PIOC_IER |= PIO_IER_P3;			//enable input rising edge interrupt
  400810:	4a77      	ldr	r2, [pc, #476]	; (4009f0 <Encoder_init+0x860>)
  400812:	6811      	ldr	r1, [r2, #0]
  400814:	f041 0108 	orr.w	r1, r1, #8
  400818:	6011      	str	r1, [r2, #0]
	REG_PIOC_REHLSR |= PIO_REHLSR_P3;
  40081a:	6819      	ldr	r1, [r3, #0]
  40081c:	f041 0108 	orr.w	r1, r1, #8
  400820:	6019      	str	r1, [r3, #0]

	//Enable interrupts for Encoder 3
	REG_PIOC_IER |= PIO_IER_P4;			//enable input rising edge interrupt
  400822:	6811      	ldr	r1, [r2, #0]
  400824:	f041 0110 	orr.w	r1, r1, #16
  400828:	6011      	str	r1, [r2, #0]
	REG_PIOC_REHLSR |= PIO_REHLSR_P4;
  40082a:	6819      	ldr	r1, [r3, #0]
  40082c:	f041 0110 	orr.w	r1, r1, #16
  400830:	6019      	str	r1, [r3, #0]
	REG_PIOC_IER |= PIO_IER_P5;			//enable input rising edge interrupt
  400832:	6811      	ldr	r1, [r2, #0]
  400834:	f041 0120 	orr.w	r1, r1, #32
  400838:	6011      	str	r1, [r2, #0]
	REG_PIOC_REHLSR |= PIO_REHLSR_P5;
  40083a:	6819      	ldr	r1, [r3, #0]
  40083c:	f041 0120 	orr.w	r1, r1, #32
  400840:	6019      	str	r1, [r3, #0]

	//Enable interrupts for Encoder 4
	REG_PIOC_IER |= PIO_IER_P6;			//enable input rising edge interrupt
  400842:	6811      	ldr	r1, [r2, #0]
  400844:	f041 0140 	orr.w	r1, r1, #64	; 0x40
  400848:	6011      	str	r1, [r2, #0]
	REG_PIOC_REHLSR |= PIO_REHLSR_P6;
  40084a:	6819      	ldr	r1, [r3, #0]
  40084c:	f041 0140 	orr.w	r1, r1, #64	; 0x40
  400850:	6019      	str	r1, [r3, #0]
	REG_PIOC_IER |= PIO_IER_P7;			//enable input rising edge interrupt
  400852:	6811      	ldr	r1, [r2, #0]
  400854:	f041 0180 	orr.w	r1, r1, #128	; 0x80
  400858:	6011      	str	r1, [r2, #0]
	REG_PIOC_REHLSR |= PIO_REHLSR_P7;
  40085a:	6819      	ldr	r1, [r3, #0]
  40085c:	f041 0180 	orr.w	r1, r1, #128	; 0x80
  400860:	6019      	str	r1, [r3, #0]

	//Enable interrupts for Encoder 5
	REG_PIOC_IER |= PIO_IER_P8;			//enable input rising edge interrupt
  400862:	6811      	ldr	r1, [r2, #0]
  400864:	f441 7180 	orr.w	r1, r1, #256	; 0x100
  400868:	6011      	str	r1, [r2, #0]
	REG_PIOC_REHLSR |= PIO_REHLSR_P8;
  40086a:	6819      	ldr	r1, [r3, #0]
  40086c:	f441 7180 	orr.w	r1, r1, #256	; 0x100
  400870:	6019      	str	r1, [r3, #0]
	REG_PIOC_IER |= PIO_IER_P9;			//enable input rising edge interrupt
  400872:	6811      	ldr	r1, [r2, #0]
  400874:	f441 7100 	orr.w	r1, r1, #512	; 0x200
  400878:	6011      	str	r1, [r2, #0]
	REG_PIOC_REHLSR |= PIO_REHLSR_P9;
  40087a:	6819      	ldr	r1, [r3, #0]
  40087c:	f441 7100 	orr.w	r1, r1, #512	; 0x200
  400880:	6019      	str	r1, [r3, #0]

	//Enable interrupts for Encoder 6
	REG_PIOC_IER |= PIO_IER_P10;			//enable input rising edge interrupt
  400882:	6811      	ldr	r1, [r2, #0]
  400884:	f441 6180 	orr.w	r1, r1, #1024	; 0x400
  400888:	6011      	str	r1, [r2, #0]
	REG_PIOC_REHLSR |= PIO_REHLSR_P10;
  40088a:	6819      	ldr	r1, [r3, #0]
  40088c:	f441 6180 	orr.w	r1, r1, #1024	; 0x400
  400890:	6019      	str	r1, [r3, #0]
	REG_PIOC_IER |= PIO_IER_P11;			//enable input rising edge interrupt
  400892:	6811      	ldr	r1, [r2, #0]
  400894:	f441 6100 	orr.w	r1, r1, #2048	; 0x800
  400898:	6011      	str	r1, [r2, #0]
	REG_PIOC_REHLSR |= PIO_REHLSR_P11;
  40089a:	6819      	ldr	r1, [r3, #0]
  40089c:	f441 6100 	orr.w	r1, r1, #2048	; 0x800
  4008a0:	6019      	str	r1, [r3, #0]

	//Enable interrupts for Encoder 7
	REG_PIOC_IER |= PIO_IER_P3;			//enable input rising edge interrupt
  4008a2:	6811      	ldr	r1, [r2, #0]
  4008a4:	f041 0108 	orr.w	r1, r1, #8
  4008a8:	6011      	str	r1, [r2, #0]
	REG_PIOC_REHLSR |= PIO_REHLSR_P3;
  4008aa:	6819      	ldr	r1, [r3, #0]
  4008ac:	f041 0108 	orr.w	r1, r1, #8
  4008b0:	6019      	str	r1, [r3, #0]
	REG_PIOC_IER |= PIO_IER_P13;			//enable input rising edge interrupt
  4008b2:	6811      	ldr	r1, [r2, #0]
  4008b4:	f441 5100 	orr.w	r1, r1, #8192	; 0x2000
  4008b8:	6011      	str	r1, [r2, #0]
	REG_PIOC_REHLSR |= PIO_REHLSR_P13;
  4008ba:	6819      	ldr	r1, [r3, #0]
  4008bc:	f441 5100 	orr.w	r1, r1, #8192	; 0x2000
  4008c0:	6019      	str	r1, [r3, #0]

	//Enable interrupts for Encoder 8
	REG_PIOC_IER |= PIO_IER_P14;			//enable input rising edge interrupt
  4008c2:	6811      	ldr	r1, [r2, #0]
  4008c4:	f441 4180 	orr.w	r1, r1, #16384	; 0x4000
  4008c8:	6011      	str	r1, [r2, #0]
	REG_PIOC_REHLSR |= PIO_REHLSR_P14;
  4008ca:	6819      	ldr	r1, [r3, #0]
  4008cc:	f441 4180 	orr.w	r1, r1, #16384	; 0x4000
  4008d0:	6019      	str	r1, [r3, #0]
	REG_PIOC_IER |= PIO_IER_P15;			//enable input rising edge interrupt
  4008d2:	6811      	ldr	r1, [r2, #0]
  4008d4:	f441 4100 	orr.w	r1, r1, #32768	; 0x8000
  4008d8:	6011      	str	r1, [r2, #0]
	REG_PIOC_REHLSR |= PIO_REHLSR_P15;
  4008da:	6819      	ldr	r1, [r3, #0]
  4008dc:	f441 4100 	orr.w	r1, r1, #32768	; 0x8000
  4008e0:	6019      	str	r1, [r3, #0]

	//Enable interrupts for Encoder 9
	REG_PIOC_IER |= PIO_IER_P16;			//enable input rising edge interrupt
  4008e2:	6811      	ldr	r1, [r2, #0]
  4008e4:	f441 3180 	orr.w	r1, r1, #65536	; 0x10000
  4008e8:	6011      	str	r1, [r2, #0]
	REG_PIOC_REHLSR |= PIO_REHLSR_P16;
  4008ea:	6819      	ldr	r1, [r3, #0]
  4008ec:	f441 3180 	orr.w	r1, r1, #65536	; 0x10000
  4008f0:	6019      	str	r1, [r3, #0]
	REG_PIOC_IER |= PIO_IER_P17;			//enable input rising edge interrupt
  4008f2:	6811      	ldr	r1, [r2, #0]
  4008f4:	f441 3100 	orr.w	r1, r1, #131072	; 0x20000
  4008f8:	6011      	str	r1, [r2, #0]
	REG_PIOC_REHLSR |= PIO_REHLSR_P17;
  4008fa:	6819      	ldr	r1, [r3, #0]
  4008fc:	f441 3100 	orr.w	r1, r1, #131072	; 0x20000
  400900:	6019      	str	r1, [r3, #0]

	//Enable interrupts for Encoder 10
	REG_PIOC_IER |= PIO_IER_P18;			//enable input rising edge interrupt
  400902:	6811      	ldr	r1, [r2, #0]
  400904:	f441 2180 	orr.w	r1, r1, #262144	; 0x40000
  400908:	6011      	str	r1, [r2, #0]
	REG_PIOC_REHLSR |= PIO_REHLSR_P18;
  40090a:	6819      	ldr	r1, [r3, #0]
  40090c:	f441 2180 	orr.w	r1, r1, #262144	; 0x40000
  400910:	6019      	str	r1, [r3, #0]
	REG_PIOC_IER |= PIO_IER_P19;			//enable input rising edge interrupt
  400912:	6811      	ldr	r1, [r2, #0]
  400914:	f441 2100 	orr.w	r1, r1, #524288	; 0x80000
  400918:	6011      	str	r1, [r2, #0]
	REG_PIOC_REHLSR |= PIO_REHLSR_P19;
  40091a:	6819      	ldr	r1, [r3, #0]
  40091c:	f441 2100 	orr.w	r1, r1, #524288	; 0x80000
  400920:	6019      	str	r1, [r3, #0]

	//Enable interrupts for Encoder 11
	REG_PIOC_IER |= PIO_IER_P20;			//enable input rising edge interrupt
  400922:	6811      	ldr	r1, [r2, #0]
  400924:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
  400928:	6011      	str	r1, [r2, #0]
	REG_PIOC_REHLSR |= PIO_REHLSR_P20;
  40092a:	6819      	ldr	r1, [r3, #0]
  40092c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
  400930:	6019      	str	r1, [r3, #0]
	REG_PIOC_IER |= PIO_IER_P21;			//enable input rising edge interrupt
  400932:	6811      	ldr	r1, [r2, #0]
  400934:	f441 1100 	orr.w	r1, r1, #2097152	; 0x200000
  400938:	6011      	str	r1, [r2, #0]
	REG_PIOC_REHLSR |= PIO_REHLSR_P21;
  40093a:	6819      	ldr	r1, [r3, #0]
  40093c:	f441 1100 	orr.w	r1, r1, #2097152	; 0x200000
  400940:	6019      	str	r1, [r3, #0]

	//Enable interrupts for Encoder 12
	REG_PIOC_IER |= PIO_IER_P22;			//enable input rising edge interrupt
  400942:	6811      	ldr	r1, [r2, #0]
  400944:	f441 0180 	orr.w	r1, r1, #4194304	; 0x400000
  400948:	6011      	str	r1, [r2, #0]
	REG_PIOC_REHLSR |= PIO_REHLSR_P22;
  40094a:	6819      	ldr	r1, [r3, #0]
  40094c:	f441 0180 	orr.w	r1, r1, #4194304	; 0x400000
  400950:	6019      	str	r1, [r3, #0]
	REG_PIOC_IER |= PIO_IER_P23;			//enable input rising edge interrupt
  400952:	6811      	ldr	r1, [r2, #0]
  400954:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
  400958:	6011      	str	r1, [r2, #0]
	REG_PIOC_REHLSR |= PIO_REHLSR_P23;
  40095a:	6819      	ldr	r1, [r3, #0]
  40095c:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
  400960:	6019      	str	r1, [r3, #0]

	//Enable interrupts for Encoder 13
	REG_PIOC_IER |= PIO_IER_P24;			//enable input rising edge interrupt
  400962:	6811      	ldr	r1, [r2, #0]
  400964:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
  400968:	6011      	str	r1, [r2, #0]
	REG_PIOC_REHLSR |= PIO_REHLSR_P24;
  40096a:	6819      	ldr	r1, [r3, #0]
  40096c:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
  400970:	6019      	str	r1, [r3, #0]
	REG_PIOC_IER |= PIO_IER_P25;			//enable input rising edge interrupt
  400972:	6811      	ldr	r1, [r2, #0]
  400974:	f041 7100 	orr.w	r1, r1, #33554432	; 0x2000000
  400978:	6011      	str	r1, [r2, #0]
	REG_PIOC_REHLSR |= PIO_REHLSR_P25;
  40097a:	6819      	ldr	r1, [r3, #0]
  40097c:	f041 7100 	orr.w	r1, r1, #33554432	; 0x2000000
  400980:	6019      	str	r1, [r3, #0]

	//Enable interrupts for Encoder 14
	REG_PIOC_IER |= PIO_IER_P26;			//enable input rising edge interrupt
  400982:	6811      	ldr	r1, [r2, #0]
  400984:	f041 6180 	orr.w	r1, r1, #67108864	; 0x4000000
  400988:	6011      	str	r1, [r2, #0]
	REG_PIOC_REHLSR |= PIO_REHLSR_P26;
  40098a:	6819      	ldr	r1, [r3, #0]
  40098c:	f041 6180 	orr.w	r1, r1, #67108864	; 0x4000000
  400990:	6019      	str	r1, [r3, #0]
	REG_PIOC_IER |= PIO_IER_P27;			//enable input rising edge interrupt
  400992:	6811      	ldr	r1, [r2, #0]
  400994:	f041 6100 	orr.w	r1, r1, #134217728	; 0x8000000
  400998:	6011      	str	r1, [r2, #0]
	REG_PIOC_REHLSR |= PIO_REHLSR_P27;
  40099a:	6819      	ldr	r1, [r3, #0]
  40099c:	f041 6100 	orr.w	r1, r1, #134217728	; 0x8000000
  4009a0:	6019      	str	r1, [r3, #0]

	//Enable interrupts for Encoder 15
	REG_PIOC_IER |= PIO_IER_P28;			//enable input rising edge interrupt
  4009a2:	6811      	ldr	r1, [r2, #0]
  4009a4:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
  4009a8:	6011      	str	r1, [r2, #0]
	REG_PIOC_REHLSR |= PIO_REHLSR_P28;
  4009aa:	6819      	ldr	r1, [r3, #0]
  4009ac:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
  4009b0:	6019      	str	r1, [r3, #0]
	REG_PIOC_IER |= PIO_IER_P29;			//enable input rising edge interrupt
  4009b2:	6811      	ldr	r1, [r2, #0]
  4009b4:	f041 5100 	orr.w	r1, r1, #536870912	; 0x20000000
  4009b8:	6011      	str	r1, [r2, #0]
	REG_PIOC_REHLSR |= PIO_REHLSR_P29;
  4009ba:	6819      	ldr	r1, [r3, #0]
  4009bc:	f041 5100 	orr.w	r1, r1, #536870912	; 0x20000000
  4009c0:	6019      	str	r1, [r3, #0]

	//Enable interrupts for Encoder 16
	REG_PIOC_IER |= PIO_IER_P30;			//enable input rising edge interrupt
  4009c2:	6811      	ldr	r1, [r2, #0]
  4009c4:	f041 4180 	orr.w	r1, r1, #1073741824	; 0x40000000
  4009c8:	6011      	str	r1, [r2, #0]
	REG_PIOC_REHLSR |= PIO_REHLSR_P30;
  4009ca:	6819      	ldr	r1, [r3, #0]
  4009cc:	f041 4180 	orr.w	r1, r1, #1073741824	; 0x40000000
  4009d0:	6019      	str	r1, [r3, #0]
	REG_PIOC_IER |= PIO_IER_P31;			//enable input rising edge interrupt
  4009d2:	6811      	ldr	r1, [r2, #0]
  4009d4:	f041 4100 	orr.w	r1, r1, #2147483648	; 0x80000000
  4009d8:	6011      	str	r1, [r2, #0]
	REG_PIOC_REHLSR |= PIO_REHLSR_P31;
  4009da:	681a      	ldr	r2, [r3, #0]
  4009dc:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
  4009e0:	601a      	str	r2, [r3, #0]
    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
/*  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  enable interrupt */
  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
  4009e2:	f44f 5200 	mov.w	r2, #8192	; 0x2000
  4009e6:	4b04      	ldr	r3, [pc, #16]	; (4009f8 <Encoder_init+0x868>)
  4009e8:	601a      	str	r2, [r3, #0]

	NVIC_EnableIRQ(PIOC_IRQn);			//enable PORT C interrupts
}
  4009ea:	bc70      	pop	{r4, r5, r6}
  4009ec:	4770      	bx	lr
  4009ee:	bf00      	nop
  4009f0:	400e1240 	.word	0x400e1240
  4009f4:	400e12d4 	.word	0x400e12d4
  4009f8:	e000e100 	.word	0xe000e100

004009fc <PIOC_Handler>:



void PIOC_Handler(){
  4009fc:	b508      	push	{r3, lr}

	uint32_t status = REG_PIOC_ISR;	//read PIOC interrupt status & clear interrupt flags
  4009fe:	4b07      	ldr	r3, [pc, #28]	; (400a1c <PIOC_Handler+0x20>)
  400a00:	681a      	ldr	r2, [r3, #0]
	else if ( (status & PIO_ISR_P16) || (status & PIO_ISR_P17) ){
		
	}

	//check if Encoder 10 was rotated
	else if ( (status & PIO_ISR_P18) || (status & PIO_ISR_P19) ){
  400a02:	4b07      	ldr	r3, [pc, #28]	; (400a20 <PIOC_Handler+0x24>)
  400a04:	4013      	ands	r3, r2
  400a06:	b943      	cbnz	r3, 400a1a <PIOC_Handler+0x1e>
		
	}

	//check if Encoder 11 was rotated
	else if ( (status & PIO_ISR_P20) || (status & PIO_ISR_P21) ){
  400a08:	f412 1f40 	tst.w	r2, #3145728	; 0x300000
  400a0c:	d005      	beq.n	400a1a <PIOC_Handler+0x1e>
		Encoder_isRight(PIO_ODSR_P20, PIO_ODSR_P21);
  400a0e:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
  400a12:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
  400a16:	4b03      	ldr	r3, [pc, #12]	; (400a24 <PIOC_Handler+0x28>)
  400a18:	4798      	blx	r3
  400a1a:	bd08      	pop	{r3, pc}
  400a1c:	400e124c 	.word	0x400e124c
  400a20:	000fefff 	.word	0x000fefff
  400a24:	0040011d 	.word	0x0040011d

00400a28 <leds_update_display>:
void leds_update_note(uint8_t led_pos){

	leds_update_display();
}

 void leds_update_display(){
  400a28:	b570      	push	{r4, r5, r6, lr}
 
	//Set Write Command, Function, and BC Bits
	SPI_byteSend(0x94);
  400a2a:	2094      	movs	r0, #148	; 0x94
  400a2c:	4c2b      	ldr	r4, [pc, #172]	; (400adc <leds_update_display+0xb4>)
  400a2e:	47a0      	blx	r4
	SPI_byteSend(0x5F);
  400a30:	205f      	movs	r0, #95	; 0x5f
  400a32:	47a0      	blx	r4
	SPI_byteSend(0xFF);
  400a34:	20ff      	movs	r0, #255	; 0xff
  400a36:	47a0      	blx	r4
	SPI_byteSend(0xFF);
  400a38:	20ff      	movs	r0, #255	; 0xff
  400a3a:	47a0      	blx	r4
  400a3c:	4e28      	ldr	r6, [pc, #160]	; (400ae0 <leds_update_display+0xb8>)
  400a3e:	f106 0418 	add.w	r4, r6, #24
	
	//set PWM GrayScale Bits (BITS 191-0)
	for (int i = 11; i > -1; i--){
		SPI_byteSend( (uint8_t) (leds_data_4[i] >> 8) );
  400a42:	4d26      	ldr	r5, [pc, #152]	; (400adc <leds_update_display+0xb4>)
  400a44:	f834 0d02 	ldrh.w	r0, [r4, #-2]!
  400a48:	0a00      	lsrs	r0, r0, #8
  400a4a:	47a8      	blx	r5
		SPI_byteSend( (uint8_t) (leds_data_4[i]) );
  400a4c:	7820      	ldrb	r0, [r4, #0]
  400a4e:	47a8      	blx	r5
	SPI_byteSend(0x5F);
	SPI_byteSend(0xFF);
	SPI_byteSend(0xFF);
	
	//set PWM GrayScale Bits (BITS 191-0)
	for (int i = 11; i > -1; i--){
  400a50:	42b4      	cmp	r4, r6
  400a52:	d1f7      	bne.n	400a44 <leds_update_display+0x1c>
		SPI_byteSend( (uint8_t) (leds_data_4[i] >> 8) );
		SPI_byteSend( (uint8_t) (leds_data_4[i]) );
	}

	//Set Write Command, Function, and BC Bits
	SPI_byteSend(0x94);
  400a54:	2094      	movs	r0, #148	; 0x94
  400a56:	4c21      	ldr	r4, [pc, #132]	; (400adc <leds_update_display+0xb4>)
  400a58:	47a0      	blx	r4
	SPI_byteSend(0x5F);
  400a5a:	205f      	movs	r0, #95	; 0x5f
  400a5c:	47a0      	blx	r4
	SPI_byteSend(0xFF);
  400a5e:	20ff      	movs	r0, #255	; 0xff
  400a60:	47a0      	blx	r4
	SPI_byteSend(0xFF);
  400a62:	20ff      	movs	r0, #255	; 0xff
  400a64:	47a0      	blx	r4
  400a66:	4e1f      	ldr	r6, [pc, #124]	; (400ae4 <leds_update_display+0xbc>)
  400a68:	f106 0418 	add.w	r4, r6, #24
	
	//set PWM GrayScale Bits (BITS 191-0)
	for (int i = 11; i > -1; i--){
		SPI_byteSend( (uint8_t) (leds_data_3[i] >> 8) );
  400a6c:	4d1b      	ldr	r5, [pc, #108]	; (400adc <leds_update_display+0xb4>)
  400a6e:	f834 0d02 	ldrh.w	r0, [r4, #-2]!
  400a72:	0a00      	lsrs	r0, r0, #8
  400a74:	47a8      	blx	r5
		SPI_byteSend( (uint8_t) (leds_data_3[i]) );
  400a76:	7820      	ldrb	r0, [r4, #0]
  400a78:	47a8      	blx	r5
	SPI_byteSend(0x5F);
	SPI_byteSend(0xFF);
	SPI_byteSend(0xFF);
	
	//set PWM GrayScale Bits (BITS 191-0)
	for (int i = 11; i > -1; i--){
  400a7a:	42b4      	cmp	r4, r6
  400a7c:	d1f7      	bne.n	400a6e <leds_update_display+0x46>
		SPI_byteSend( (uint8_t) (leds_data_3[i] >> 8) );
		SPI_byteSend( (uint8_t) (leds_data_3[i]) );
	}

	//Set Write Command, Function, and BC Bits
	SPI_byteSend(0x94);
  400a7e:	2094      	movs	r0, #148	; 0x94
  400a80:	4c16      	ldr	r4, [pc, #88]	; (400adc <leds_update_display+0xb4>)
  400a82:	47a0      	blx	r4
	SPI_byteSend(0x5F);
  400a84:	205f      	movs	r0, #95	; 0x5f
  400a86:	47a0      	blx	r4
	SPI_byteSend(0xFF);
  400a88:	20ff      	movs	r0, #255	; 0xff
  400a8a:	47a0      	blx	r4
	SPI_byteSend(0xFF);
  400a8c:	20ff      	movs	r0, #255	; 0xff
  400a8e:	47a0      	blx	r4
  400a90:	4e15      	ldr	r6, [pc, #84]	; (400ae8 <leds_update_display+0xc0>)
  400a92:	f106 0418 	add.w	r4, r6, #24

	//set PWM GrayScale Bits (BITS 191-0)
	for (int i = 11; i > -1; i--){
		SPI_byteSend( (uint8_t) (leds_data_2[i] >> 8) );
  400a96:	4d11      	ldr	r5, [pc, #68]	; (400adc <leds_update_display+0xb4>)
  400a98:	f834 0d02 	ldrh.w	r0, [r4, #-2]!
  400a9c:	0a00      	lsrs	r0, r0, #8
  400a9e:	47a8      	blx	r5
		SPI_byteSend( (uint8_t) (leds_data_2[i]) );
  400aa0:	7820      	ldrb	r0, [r4, #0]
  400aa2:	47a8      	blx	r5
	SPI_byteSend(0x5F);
	SPI_byteSend(0xFF);
	SPI_byteSend(0xFF);

	//set PWM GrayScale Bits (BITS 191-0)
	for (int i = 11; i > -1; i--){
  400aa4:	42a6      	cmp	r6, r4
  400aa6:	d1f7      	bne.n	400a98 <leds_update_display+0x70>
		SPI_byteSend( (uint8_t) (leds_data_2[i] >> 8) );
		SPI_byteSend( (uint8_t) (leds_data_2[i]) );
	}

	//Set Write Command, Function, and BC Bits
	SPI_byteSend(0x94);
  400aa8:	2094      	movs	r0, #148	; 0x94
  400aaa:	4c0c      	ldr	r4, [pc, #48]	; (400adc <leds_update_display+0xb4>)
  400aac:	47a0      	blx	r4
	SPI_byteSend(0x5F);
  400aae:	205f      	movs	r0, #95	; 0x5f
  400ab0:	47a0      	blx	r4
	SPI_byteSend(0xFF);
  400ab2:	20ff      	movs	r0, #255	; 0xff
  400ab4:	47a0      	blx	r4
	SPI_byteSend(0xFF);
  400ab6:	20ff      	movs	r0, #255	; 0xff
  400ab8:	47a0      	blx	r4
  400aba:	4e0c      	ldr	r6, [pc, #48]	; (400aec <leds_update_display+0xc4>)
  400abc:	f106 0418 	add.w	r4, r6, #24
	
	//set PWM GrayScale Bits (BITS 191-0)
	for (int i = 11; i > -1; i--){
		SPI_byteSend( (uint8_t) (leds_data_1[i] >> 8) );
  400ac0:	4d06      	ldr	r5, [pc, #24]	; (400adc <leds_update_display+0xb4>)
  400ac2:	f834 0d02 	ldrh.w	r0, [r4, #-2]!
  400ac6:	0a00      	lsrs	r0, r0, #8
  400ac8:	47a8      	blx	r5
		SPI_byteSend( (uint8_t) (leds_data_1[i]) );
  400aca:	7820      	ldrb	r0, [r4, #0]
  400acc:	47a8      	blx	r5
	SPI_byteSend(0x5F);
	SPI_byteSend(0xFF);
	SPI_byteSend(0xFF);
	
	//set PWM GrayScale Bits (BITS 191-0)
	for (int i = 11; i > -1; i--){
  400ace:	42b4      	cmp	r4, r6
  400ad0:	d1f7      	bne.n	400ac2 <leds_update_display+0x9a>
		SPI_byteSend( (uint8_t) (leds_data_1[i] >> 8) );
		SPI_byteSend( (uint8_t) (leds_data_1[i]) );
	}

	delay_ms(2.74);
  400ad2:	f243 70ce 	movw	r0, #14286	; 0x37ce
  400ad6:	4b06      	ldr	r3, [pc, #24]	; (400af0 <leds_update_display+0xc8>)
  400ad8:	4798      	blx	r3
  400ada:	bd70      	pop	{r4, r5, r6, pc}
  400adc:	00400f05 	.word	0x00400f05
  400ae0:	20000054 	.word	0x20000054
  400ae4:	2000003c 	.word	0x2000003c
  400ae8:	20000024 	.word	0x20000024
  400aec:	2000000c 	.word	0x2000000c
  400af0:	20000001 	.word	0x20000001

00400af4 <leds_update_cursor>:
void leds_update_note(uint8_t led_pos);
void leds_update_display();



void leds_update_cursor(uint8_t curr_step){
  400af4:	b508      	push	{r3, lr}

	switch(curr_step){
  400af6:	280f      	cmp	r0, #15
  400af8:	f200 8190 	bhi.w	400e1c <leds_update_cursor+0x328>
  400afc:	e8df f010 	tbh	[pc, r0, lsl #1]
  400b00:	00280010 	.word	0x00280010
  400b04:	0056003f 	.word	0x0056003f
  400b08:	0085006d 	.word	0x0085006d
  400b0c:	00b3009c 	.word	0x00b3009c
  400b10:	00e200ca 	.word	0x00e200ca
  400b14:	011000f9 	.word	0x011000f9
  400b18:	014a0132 	.word	0x014a0132
  400b1c:	01780161 	.word	0x01780161
		case 0 : 
			leds_data_4[9] = leds_prev_data[0];
  400b20:	4b8b      	ldr	r3, [pc, #556]	; (400d50 <leds_update_cursor+0x25c>)
  400b22:	4a8c      	ldr	r2, [pc, #560]	; (400d54 <leds_update_cursor+0x260>)
  400b24:	8811      	ldrh	r1, [r2, #0]
  400b26:	8259      	strh	r1, [r3, #18]
			leds_data_4[10] = leds_prev_data[1];
  400b28:	8851      	ldrh	r1, [r2, #2]
  400b2a:	8299      	strh	r1, [r3, #20]
			leds_data_4[11] = leds_prev_data[2];
  400b2c:	8891      	ldrh	r1, [r2, #4]
  400b2e:	82d9      	strh	r1, [r3, #22]

			leds_prev_data[0] = leds_data_1[0];
  400b30:	4b89      	ldr	r3, [pc, #548]	; (400d58 <leds_update_cursor+0x264>)
  400b32:	8819      	ldrh	r1, [r3, #0]
  400b34:	8011      	strh	r1, [r2, #0]
			leds_prev_data[1] = leds_data_1[1];
  400b36:	8859      	ldrh	r1, [r3, #2]
  400b38:	8051      	strh	r1, [r2, #2]
			leds_prev_data[2] = leds_data_1[2];
  400b3a:	8899      	ldrh	r1, [r3, #4]
  400b3c:	8091      	strh	r1, [r2, #4]

			leds_data_1[0] = 0x1FFF;
  400b3e:	f641 72ff 	movw	r2, #8191	; 0x1fff
  400b42:	801a      	strh	r2, [r3, #0]
			leds_data_1[1] = 0x03FF;
  400b44:	f240 32ff 	movw	r2, #1023	; 0x3ff
  400b48:	805a      	strh	r2, [r3, #2]
			leds_data_1[2] = 0x0000;
  400b4a:	2200      	movs	r2, #0
  400b4c:	809a      	strh	r2, [r3, #4]
			break;
  400b4e:	e165      	b.n	400e1c <leds_update_cursor+0x328>
		case 1 :
			leds_data_1[0] = leds_prev_data[0];
  400b50:	4b81      	ldr	r3, [pc, #516]	; (400d58 <leds_update_cursor+0x264>)
  400b52:	4a80      	ldr	r2, [pc, #512]	; (400d54 <leds_update_cursor+0x260>)
  400b54:	8811      	ldrh	r1, [r2, #0]
  400b56:	8019      	strh	r1, [r3, #0]
			leds_data_1[1] = leds_prev_data[1];
  400b58:	8851      	ldrh	r1, [r2, #2]
  400b5a:	8059      	strh	r1, [r3, #2]
			leds_data_1[2] = leds_prev_data[2];
  400b5c:	8891      	ldrh	r1, [r2, #4]
  400b5e:	8099      	strh	r1, [r3, #4]

			leds_prev_data[0] = leds_data_1[3];
  400b60:	88d9      	ldrh	r1, [r3, #6]
  400b62:	8011      	strh	r1, [r2, #0]
			leds_prev_data[1] = leds_data_1[4];
  400b64:	8919      	ldrh	r1, [r3, #8]
  400b66:	8051      	strh	r1, [r2, #2]
			leds_prev_data[2] = leds_data_1[5];
  400b68:	8959      	ldrh	r1, [r3, #10]
  400b6a:	8091      	strh	r1, [r2, #4]

			leds_data_1[3] = 0x1FFF;
  400b6c:	f641 72ff 	movw	r2, #8191	; 0x1fff
  400b70:	80da      	strh	r2, [r3, #6]
			leds_data_1[4] = 0x03FF;
  400b72:	f240 32ff 	movw	r2, #1023	; 0x3ff
  400b76:	811a      	strh	r2, [r3, #8]
			leds_data_1[5] = 0x0000;
  400b78:	2200      	movs	r2, #0
  400b7a:	815a      	strh	r2, [r3, #10]
			break;
  400b7c:	e14e      	b.n	400e1c <leds_update_cursor+0x328>
		case 2 :
			leds_data_1[3] = leds_prev_data[0];
  400b7e:	4b76      	ldr	r3, [pc, #472]	; (400d58 <leds_update_cursor+0x264>)
  400b80:	4a74      	ldr	r2, [pc, #464]	; (400d54 <leds_update_cursor+0x260>)
  400b82:	8811      	ldrh	r1, [r2, #0]
  400b84:	80d9      	strh	r1, [r3, #6]
			leds_data_1[4] = leds_prev_data[1];
  400b86:	8851      	ldrh	r1, [r2, #2]
  400b88:	8119      	strh	r1, [r3, #8]
			leds_data_1[5] = leds_prev_data[2];
  400b8a:	8891      	ldrh	r1, [r2, #4]
  400b8c:	8159      	strh	r1, [r3, #10]

			leds_prev_data[0] = leds_data_1[6];
  400b8e:	8999      	ldrh	r1, [r3, #12]
  400b90:	8011      	strh	r1, [r2, #0]
			leds_prev_data[1] = leds_data_1[7];
  400b92:	89d9      	ldrh	r1, [r3, #14]
  400b94:	8051      	strh	r1, [r2, #2]
			leds_prev_data[2] = leds_data_1[8];
  400b96:	8a19      	ldrh	r1, [r3, #16]
  400b98:	8091      	strh	r1, [r2, #4]

			leds_data_1[6] = 0x1FFF;
  400b9a:	f641 72ff 	movw	r2, #8191	; 0x1fff
  400b9e:	819a      	strh	r2, [r3, #12]
			leds_data_1[7] = 0x03FF;
  400ba0:	f240 32ff 	movw	r2, #1023	; 0x3ff
  400ba4:	81da      	strh	r2, [r3, #14]
			leds_data_1[8] = 0x0000;
  400ba6:	2200      	movs	r2, #0
  400ba8:	821a      	strh	r2, [r3, #16]
			break;
  400baa:	e137      	b.n	400e1c <leds_update_cursor+0x328>
		case 3 :
			leds_data_1[6] = leds_prev_data[0];
  400bac:	4b6a      	ldr	r3, [pc, #424]	; (400d58 <leds_update_cursor+0x264>)
  400bae:	4a69      	ldr	r2, [pc, #420]	; (400d54 <leds_update_cursor+0x260>)
  400bb0:	8811      	ldrh	r1, [r2, #0]
  400bb2:	8199      	strh	r1, [r3, #12]
			leds_data_1[7] = leds_prev_data[1];
  400bb4:	8851      	ldrh	r1, [r2, #2]
  400bb6:	81d9      	strh	r1, [r3, #14]
			leds_data_1[8] = leds_prev_data[2];
  400bb8:	8891      	ldrh	r1, [r2, #4]
  400bba:	8219      	strh	r1, [r3, #16]

			leds_prev_data[0] = leds_data_1[9];
  400bbc:	8a59      	ldrh	r1, [r3, #18]
  400bbe:	8011      	strh	r1, [r2, #0]
			leds_prev_data[1] = leds_data_1[10];
  400bc0:	8a99      	ldrh	r1, [r3, #20]
  400bc2:	8051      	strh	r1, [r2, #2]
			leds_prev_data[2] = leds_data_1[11];
  400bc4:	8ad9      	ldrh	r1, [r3, #22]
  400bc6:	8091      	strh	r1, [r2, #4]

			leds_data_1[9] = 0x1FFF;
  400bc8:	f641 72ff 	movw	r2, #8191	; 0x1fff
  400bcc:	825a      	strh	r2, [r3, #18]
			leds_data_1[10] = 0x03FF;
  400bce:	f240 32ff 	movw	r2, #1023	; 0x3ff
  400bd2:	829a      	strh	r2, [r3, #20]
			leds_data_1[11] = 0x0000;
  400bd4:	2200      	movs	r2, #0
  400bd6:	82da      	strh	r2, [r3, #22]
			break;
  400bd8:	e120      	b.n	400e1c <leds_update_cursor+0x328>
		case 4 :
			leds_data_1[9] = leds_prev_data[0];
  400bda:	4b5f      	ldr	r3, [pc, #380]	; (400d58 <leds_update_cursor+0x264>)
  400bdc:	4a5d      	ldr	r2, [pc, #372]	; (400d54 <leds_update_cursor+0x260>)
  400bde:	8811      	ldrh	r1, [r2, #0]
  400be0:	8259      	strh	r1, [r3, #18]
			leds_data_1[10] = leds_prev_data[1];
  400be2:	8851      	ldrh	r1, [r2, #2]
  400be4:	8299      	strh	r1, [r3, #20]
			leds_data_1[11] = leds_prev_data[2];
  400be6:	8891      	ldrh	r1, [r2, #4]
  400be8:	82d9      	strh	r1, [r3, #22]

			leds_prev_data[0] = leds_data_2[0];
  400bea:	4b5c      	ldr	r3, [pc, #368]	; (400d5c <leds_update_cursor+0x268>)
  400bec:	8819      	ldrh	r1, [r3, #0]
  400bee:	8011      	strh	r1, [r2, #0]
			leds_prev_data[1] = leds_data_2[1];
  400bf0:	8859      	ldrh	r1, [r3, #2]
  400bf2:	8051      	strh	r1, [r2, #2]
			leds_prev_data[2] = leds_data_2[2];
  400bf4:	8899      	ldrh	r1, [r3, #4]
  400bf6:	8091      	strh	r1, [r2, #4]

			leds_data_2[0] = 0x1FFF;
  400bf8:	f641 72ff 	movw	r2, #8191	; 0x1fff
  400bfc:	801a      	strh	r2, [r3, #0]
			leds_data_2[1] = 0x03FF;
  400bfe:	f240 32ff 	movw	r2, #1023	; 0x3ff
  400c02:	805a      	strh	r2, [r3, #2]
			leds_data_2[2] = 0x0000;
  400c04:	2200      	movs	r2, #0
  400c06:	809a      	strh	r2, [r3, #4]
			break;
  400c08:	e108      	b.n	400e1c <leds_update_cursor+0x328>
		case 5 :
			leds_data_2[0] = leds_prev_data[0];
  400c0a:	4b54      	ldr	r3, [pc, #336]	; (400d5c <leds_update_cursor+0x268>)
  400c0c:	4a51      	ldr	r2, [pc, #324]	; (400d54 <leds_update_cursor+0x260>)
  400c0e:	8811      	ldrh	r1, [r2, #0]
  400c10:	8019      	strh	r1, [r3, #0]
			leds_data_2[1] = leds_prev_data[1];
  400c12:	8851      	ldrh	r1, [r2, #2]
  400c14:	8059      	strh	r1, [r3, #2]
			leds_data_2[2] = leds_prev_data[2];
  400c16:	8891      	ldrh	r1, [r2, #4]
  400c18:	8099      	strh	r1, [r3, #4]

			leds_prev_data[0] = leds_data_2[3];
  400c1a:	88d9      	ldrh	r1, [r3, #6]
  400c1c:	8011      	strh	r1, [r2, #0]
			leds_prev_data[1] = leds_data_2[4];
  400c1e:	8919      	ldrh	r1, [r3, #8]
  400c20:	8051      	strh	r1, [r2, #2]
			leds_prev_data[2] = leds_data_2[5];
  400c22:	8959      	ldrh	r1, [r3, #10]
  400c24:	8091      	strh	r1, [r2, #4]

			leds_data_2[3] = 0x1FFF;
  400c26:	f641 72ff 	movw	r2, #8191	; 0x1fff
  400c2a:	80da      	strh	r2, [r3, #6]
			leds_data_2[4] = 0x03FF;
  400c2c:	f240 32ff 	movw	r2, #1023	; 0x3ff
  400c30:	811a      	strh	r2, [r3, #8]
			leds_data_2[5] = 0x0000;
  400c32:	2200      	movs	r2, #0
  400c34:	815a      	strh	r2, [r3, #10]
			break;
  400c36:	e0f1      	b.n	400e1c <leds_update_cursor+0x328>
		case 6 :
			leds_data_2[3] = leds_prev_data[0];
  400c38:	4b48      	ldr	r3, [pc, #288]	; (400d5c <leds_update_cursor+0x268>)
  400c3a:	4a46      	ldr	r2, [pc, #280]	; (400d54 <leds_update_cursor+0x260>)
  400c3c:	8811      	ldrh	r1, [r2, #0]
  400c3e:	80d9      	strh	r1, [r3, #6]
			leds_data_2[4] = leds_prev_data[1];
  400c40:	8851      	ldrh	r1, [r2, #2]
  400c42:	8119      	strh	r1, [r3, #8]
			leds_data_2[5] = leds_prev_data[2];
  400c44:	8891      	ldrh	r1, [r2, #4]
  400c46:	8159      	strh	r1, [r3, #10]

			leds_prev_data[0] = leds_data_2[6];
  400c48:	8999      	ldrh	r1, [r3, #12]
  400c4a:	8011      	strh	r1, [r2, #0]
			leds_prev_data[1] = leds_data_2[7];
  400c4c:	89d9      	ldrh	r1, [r3, #14]
  400c4e:	8051      	strh	r1, [r2, #2]
			leds_prev_data[2] = leds_data_2[8];
  400c50:	8a19      	ldrh	r1, [r3, #16]
  400c52:	8091      	strh	r1, [r2, #4]

			leds_data_2[6] = 0x1FFF;
  400c54:	f641 72ff 	movw	r2, #8191	; 0x1fff
  400c58:	819a      	strh	r2, [r3, #12]
			leds_data_2[7] = 0x03FF;
  400c5a:	f240 32ff 	movw	r2, #1023	; 0x3ff
  400c5e:	81da      	strh	r2, [r3, #14]
			leds_data_2[8] = 0x0000;
  400c60:	2200      	movs	r2, #0
  400c62:	821a      	strh	r2, [r3, #16]
			break;
  400c64:	e0da      	b.n	400e1c <leds_update_cursor+0x328>
		case 7 :
			leds_data_2[6] = leds_prev_data[0];
  400c66:	4b3d      	ldr	r3, [pc, #244]	; (400d5c <leds_update_cursor+0x268>)
  400c68:	4a3a      	ldr	r2, [pc, #232]	; (400d54 <leds_update_cursor+0x260>)
  400c6a:	8811      	ldrh	r1, [r2, #0]
  400c6c:	8199      	strh	r1, [r3, #12]
			leds_data_2[7] = leds_prev_data[1];
  400c6e:	8851      	ldrh	r1, [r2, #2]
  400c70:	81d9      	strh	r1, [r3, #14]
			leds_data_2[8] = leds_prev_data[2];
  400c72:	8891      	ldrh	r1, [r2, #4]
  400c74:	8219      	strh	r1, [r3, #16]

			leds_prev_data[0] = leds_data_2[9];
  400c76:	8a59      	ldrh	r1, [r3, #18]
  400c78:	8011      	strh	r1, [r2, #0]
			leds_prev_data[1] = leds_data_2[10];
  400c7a:	8a99      	ldrh	r1, [r3, #20]
  400c7c:	8051      	strh	r1, [r2, #2]
			leds_prev_data[2] = leds_data_2[11];
  400c7e:	8ad9      	ldrh	r1, [r3, #22]
  400c80:	8091      	strh	r1, [r2, #4]

			leds_data_2[9] = 0x1FFF;
  400c82:	f641 72ff 	movw	r2, #8191	; 0x1fff
  400c86:	825a      	strh	r2, [r3, #18]
			leds_data_2[10] = 0x03FF;
  400c88:	f240 32ff 	movw	r2, #1023	; 0x3ff
  400c8c:	829a      	strh	r2, [r3, #20]
			leds_data_2[11] = 0x0000;
  400c8e:	2200      	movs	r2, #0
  400c90:	82da      	strh	r2, [r3, #22]
			break;
  400c92:	e0c3      	b.n	400e1c <leds_update_cursor+0x328>
		case 8 :
			leds_data_2[9] = leds_prev_data[0];
  400c94:	4b31      	ldr	r3, [pc, #196]	; (400d5c <leds_update_cursor+0x268>)
  400c96:	4a2f      	ldr	r2, [pc, #188]	; (400d54 <leds_update_cursor+0x260>)
  400c98:	8811      	ldrh	r1, [r2, #0]
  400c9a:	8259      	strh	r1, [r3, #18]
			leds_data_2[10] = leds_prev_data[1];
  400c9c:	8851      	ldrh	r1, [r2, #2]
  400c9e:	8299      	strh	r1, [r3, #20]
			leds_data_2[11] = leds_prev_data[2];
  400ca0:	8891      	ldrh	r1, [r2, #4]
  400ca2:	82d9      	strh	r1, [r3, #22]

			leds_prev_data[0] = leds_data_3[0];
  400ca4:	4b2e      	ldr	r3, [pc, #184]	; (400d60 <leds_update_cursor+0x26c>)
  400ca6:	8819      	ldrh	r1, [r3, #0]
  400ca8:	8011      	strh	r1, [r2, #0]
			leds_prev_data[1] = leds_data_3[1];
  400caa:	8859      	ldrh	r1, [r3, #2]
  400cac:	8051      	strh	r1, [r2, #2]
			leds_prev_data[2] = leds_data_3[2];
  400cae:	8899      	ldrh	r1, [r3, #4]
  400cb0:	8091      	strh	r1, [r2, #4]

			leds_data_3[0] = 0x1FFF;
  400cb2:	f641 72ff 	movw	r2, #8191	; 0x1fff
  400cb6:	801a      	strh	r2, [r3, #0]
			leds_data_3[1] = 0x03FF;
  400cb8:	f240 32ff 	movw	r2, #1023	; 0x3ff
  400cbc:	805a      	strh	r2, [r3, #2]
			leds_data_3[2] = 0x0000;
  400cbe:	2200      	movs	r2, #0
  400cc0:	809a      	strh	r2, [r3, #4]
			break;
  400cc2:	e0ab      	b.n	400e1c <leds_update_cursor+0x328>
		case 9 :
			leds_data_3[0] = leds_prev_data[0];
  400cc4:	4b26      	ldr	r3, [pc, #152]	; (400d60 <leds_update_cursor+0x26c>)
  400cc6:	4a23      	ldr	r2, [pc, #140]	; (400d54 <leds_update_cursor+0x260>)
  400cc8:	8811      	ldrh	r1, [r2, #0]
  400cca:	8019      	strh	r1, [r3, #0]
			leds_data_3[1] = leds_prev_data[1];
  400ccc:	8851      	ldrh	r1, [r2, #2]
  400cce:	8059      	strh	r1, [r3, #2]
			leds_data_3[2] = leds_prev_data[2];
  400cd0:	8891      	ldrh	r1, [r2, #4]
  400cd2:	8099      	strh	r1, [r3, #4]

			leds_prev_data[0] = leds_data_3[3];
  400cd4:	88d9      	ldrh	r1, [r3, #6]
  400cd6:	8011      	strh	r1, [r2, #0]
			leds_prev_data[1] = leds_data_3[4];
  400cd8:	8919      	ldrh	r1, [r3, #8]
  400cda:	8051      	strh	r1, [r2, #2]
			leds_prev_data[2] = leds_data_3[5];
  400cdc:	8959      	ldrh	r1, [r3, #10]
  400cde:	8091      	strh	r1, [r2, #4]

			leds_data_3[3] = 0x1FFF;
  400ce0:	f641 72ff 	movw	r2, #8191	; 0x1fff
  400ce4:	80da      	strh	r2, [r3, #6]
			leds_data_3[4] = 0x03FF;
  400ce6:	f240 32ff 	movw	r2, #1023	; 0x3ff
  400cea:	811a      	strh	r2, [r3, #8]
			leds_data_3[5] = 0x0000;
  400cec:	2200      	movs	r2, #0
  400cee:	815a      	strh	r2, [r3, #10]
			break;
  400cf0:	e094      	b.n	400e1c <leds_update_cursor+0x328>
		case 10 :
			leds_data_3[3] = leds_prev_data[0];
  400cf2:	4b1b      	ldr	r3, [pc, #108]	; (400d60 <leds_update_cursor+0x26c>)
  400cf4:	4a17      	ldr	r2, [pc, #92]	; (400d54 <leds_update_cursor+0x260>)
  400cf6:	8811      	ldrh	r1, [r2, #0]
  400cf8:	80d9      	strh	r1, [r3, #6]
			leds_data_3[4] = leds_prev_data[1];
  400cfa:	8851      	ldrh	r1, [r2, #2]
  400cfc:	8119      	strh	r1, [r3, #8]
			leds_data_3[5] = leds_prev_data[2];
  400cfe:	8891      	ldrh	r1, [r2, #4]
  400d00:	8159      	strh	r1, [r3, #10]

			leds_prev_data[0] = leds_data_3[6];
  400d02:	8999      	ldrh	r1, [r3, #12]
  400d04:	8011      	strh	r1, [r2, #0]
			leds_prev_data[1] = leds_data_3[7];
  400d06:	89d9      	ldrh	r1, [r3, #14]
  400d08:	8051      	strh	r1, [r2, #2]
			leds_prev_data[2] = leds_data_3[8];
  400d0a:	8a19      	ldrh	r1, [r3, #16]
  400d0c:	8091      	strh	r1, [r2, #4]

			leds_data_3[6] = 0x1FFF;
  400d0e:	f641 72ff 	movw	r2, #8191	; 0x1fff
  400d12:	819a      	strh	r2, [r3, #12]
			leds_data_3[7] = 0x03FF;
  400d14:	f240 32ff 	movw	r2, #1023	; 0x3ff
  400d18:	81da      	strh	r2, [r3, #14]
			leds_data_3[8] = 0x0000;
  400d1a:	2200      	movs	r2, #0
  400d1c:	821a      	strh	r2, [r3, #16]
			break;
  400d1e:	e07d      	b.n	400e1c <leds_update_cursor+0x328>
		case 11 :
			leds_data_3[6] = leds_prev_data[0];
  400d20:	4b0f      	ldr	r3, [pc, #60]	; (400d60 <leds_update_cursor+0x26c>)
  400d22:	4a0c      	ldr	r2, [pc, #48]	; (400d54 <leds_update_cursor+0x260>)
  400d24:	8811      	ldrh	r1, [r2, #0]
  400d26:	8199      	strh	r1, [r3, #12]
			leds_data_3[7] = leds_prev_data[1];
  400d28:	8851      	ldrh	r1, [r2, #2]
  400d2a:	81d9      	strh	r1, [r3, #14]
			leds_data_3[8] = leds_prev_data[2];
  400d2c:	8891      	ldrh	r1, [r2, #4]
  400d2e:	8219      	strh	r1, [r3, #16]

			leds_prev_data[0] = leds_data_3[9];
  400d30:	8a59      	ldrh	r1, [r3, #18]
  400d32:	8011      	strh	r1, [r2, #0]
			leds_prev_data[1] = leds_data_3[10];
  400d34:	8a99      	ldrh	r1, [r3, #20]
  400d36:	8051      	strh	r1, [r2, #2]
			leds_prev_data[2] = leds_data_3[11];
  400d38:	8ad9      	ldrh	r1, [r3, #22]
  400d3a:	8091      	strh	r1, [r2, #4]

			leds_data_3[9] = 0x1FFF;
  400d3c:	f641 72ff 	movw	r2, #8191	; 0x1fff
  400d40:	825a      	strh	r2, [r3, #18]
			leds_data_3[10] = 0x03FF;
  400d42:	f240 32ff 	movw	r2, #1023	; 0x3ff
  400d46:	829a      	strh	r2, [r3, #20]
			leds_data_3[11] = 0x0000;
  400d48:	2200      	movs	r2, #0
  400d4a:	82da      	strh	r2, [r3, #22]
			break;
  400d4c:	e066      	b.n	400e1c <leds_update_cursor+0x328>
  400d4e:	bf00      	nop
  400d50:	20000054 	.word	0x20000054
  400d54:	2000006c 	.word	0x2000006c
  400d58:	2000000c 	.word	0x2000000c
  400d5c:	20000024 	.word	0x20000024
  400d60:	2000003c 	.word	0x2000003c
		case 12 :
			leds_data_3[9] = leds_prev_data[0];
  400d64:	4b2f      	ldr	r3, [pc, #188]	; (400e24 <leds_update_cursor+0x330>)
  400d66:	4a30      	ldr	r2, [pc, #192]	; (400e28 <leds_update_cursor+0x334>)
  400d68:	8811      	ldrh	r1, [r2, #0]
  400d6a:	8259      	strh	r1, [r3, #18]
			leds_data_3[10] = leds_prev_data[1];
  400d6c:	8851      	ldrh	r1, [r2, #2]
  400d6e:	8299      	strh	r1, [r3, #20]
			leds_data_3[11] = leds_prev_data[2];
  400d70:	8891      	ldrh	r1, [r2, #4]
  400d72:	82d9      	strh	r1, [r3, #22]

			leds_prev_data[0] = leds_data_4[0];
  400d74:	4b2d      	ldr	r3, [pc, #180]	; (400e2c <leds_update_cursor+0x338>)
  400d76:	8819      	ldrh	r1, [r3, #0]
  400d78:	8011      	strh	r1, [r2, #0]
			leds_prev_data[1] = leds_data_4[1];
  400d7a:	8859      	ldrh	r1, [r3, #2]
  400d7c:	8051      	strh	r1, [r2, #2]
			leds_prev_data[2] = leds_data_4[2];
  400d7e:	8899      	ldrh	r1, [r3, #4]
  400d80:	8091      	strh	r1, [r2, #4]

			leds_data_4[0] = 0x1FFF;
  400d82:	f641 72ff 	movw	r2, #8191	; 0x1fff
  400d86:	801a      	strh	r2, [r3, #0]
			leds_data_4[1] = 0x03FF;
  400d88:	f240 32ff 	movw	r2, #1023	; 0x3ff
  400d8c:	805a      	strh	r2, [r3, #2]
			leds_data_4[2] = 0x0000;
  400d8e:	2200      	movs	r2, #0
  400d90:	809a      	strh	r2, [r3, #4]
			break;
  400d92:	e043      	b.n	400e1c <leds_update_cursor+0x328>
		case 13 :
			leds_data_4[0] = leds_prev_data[0];
  400d94:	4b25      	ldr	r3, [pc, #148]	; (400e2c <leds_update_cursor+0x338>)
  400d96:	4a24      	ldr	r2, [pc, #144]	; (400e28 <leds_update_cursor+0x334>)
  400d98:	8811      	ldrh	r1, [r2, #0]
  400d9a:	8019      	strh	r1, [r3, #0]
			leds_data_4[1] = leds_prev_data[1];
  400d9c:	8851      	ldrh	r1, [r2, #2]
  400d9e:	8059      	strh	r1, [r3, #2]
			leds_data_4[2] = leds_prev_data[2];
  400da0:	8891      	ldrh	r1, [r2, #4]
  400da2:	8099      	strh	r1, [r3, #4]

			leds_prev_data[0] = leds_data_4[3];
  400da4:	88d9      	ldrh	r1, [r3, #6]
  400da6:	8011      	strh	r1, [r2, #0]
			leds_prev_data[1] = leds_data_4[4];
  400da8:	8919      	ldrh	r1, [r3, #8]
  400daa:	8051      	strh	r1, [r2, #2]
			leds_prev_data[2] = leds_data_4[5];
  400dac:	8959      	ldrh	r1, [r3, #10]
  400dae:	8091      	strh	r1, [r2, #4]

			leds_data_4[3] = 0x1FFF;
  400db0:	f641 72ff 	movw	r2, #8191	; 0x1fff
  400db4:	80da      	strh	r2, [r3, #6]
			leds_data_4[4] = 0x03FF;
  400db6:	f240 32ff 	movw	r2, #1023	; 0x3ff
  400dba:	811a      	strh	r2, [r3, #8]
			leds_data_4[5] = 0x0000;
  400dbc:	2200      	movs	r2, #0
  400dbe:	815a      	strh	r2, [r3, #10]
			break;
  400dc0:	e02c      	b.n	400e1c <leds_update_cursor+0x328>
		case 14 :
			leds_data_4[3] = leds_prev_data[0];
  400dc2:	4b1a      	ldr	r3, [pc, #104]	; (400e2c <leds_update_cursor+0x338>)
  400dc4:	4a18      	ldr	r2, [pc, #96]	; (400e28 <leds_update_cursor+0x334>)
  400dc6:	8811      	ldrh	r1, [r2, #0]
  400dc8:	80d9      	strh	r1, [r3, #6]
			leds_data_4[4] = leds_prev_data[1];
  400dca:	8851      	ldrh	r1, [r2, #2]
  400dcc:	8119      	strh	r1, [r3, #8]
			leds_data_4[5] = leds_prev_data[2];
  400dce:	8891      	ldrh	r1, [r2, #4]
  400dd0:	8159      	strh	r1, [r3, #10]

			leds_prev_data[0] = leds_data_4[6];
  400dd2:	8999      	ldrh	r1, [r3, #12]
  400dd4:	8011      	strh	r1, [r2, #0]
			leds_prev_data[1] = leds_data_4[7];
  400dd6:	89d9      	ldrh	r1, [r3, #14]
  400dd8:	8051      	strh	r1, [r2, #2]
			leds_prev_data[2] = leds_data_4[8];
  400dda:	8a19      	ldrh	r1, [r3, #16]
  400ddc:	8091      	strh	r1, [r2, #4]

			leds_data_4[6] = 0x1FFF;
  400dde:	f641 72ff 	movw	r2, #8191	; 0x1fff
  400de2:	819a      	strh	r2, [r3, #12]
			leds_data_4[7] = 0x03FF;
  400de4:	f240 32ff 	movw	r2, #1023	; 0x3ff
  400de8:	81da      	strh	r2, [r3, #14]
			leds_data_4[8] = 0x0000;
  400dea:	2200      	movs	r2, #0
  400dec:	821a      	strh	r2, [r3, #16]
			break;
  400dee:	e015      	b.n	400e1c <leds_update_cursor+0x328>
		case 15 :
			leds_data_4[6] = leds_prev_data[0];
  400df0:	4b0e      	ldr	r3, [pc, #56]	; (400e2c <leds_update_cursor+0x338>)
  400df2:	4a0d      	ldr	r2, [pc, #52]	; (400e28 <leds_update_cursor+0x334>)
  400df4:	8811      	ldrh	r1, [r2, #0]
  400df6:	8199      	strh	r1, [r3, #12]
			leds_data_4[7] = leds_prev_data[1];
  400df8:	8851      	ldrh	r1, [r2, #2]
  400dfa:	81d9      	strh	r1, [r3, #14]
			leds_data_4[8] = leds_prev_data[2];
  400dfc:	8891      	ldrh	r1, [r2, #4]
  400dfe:	8219      	strh	r1, [r3, #16]

			leds_prev_data[0] = leds_data_4[9];
  400e00:	8a59      	ldrh	r1, [r3, #18]
  400e02:	8011      	strh	r1, [r2, #0]
			leds_prev_data[1] = leds_data_4[10];
  400e04:	8a99      	ldrh	r1, [r3, #20]
  400e06:	8051      	strh	r1, [r2, #2]
			leds_prev_data[2] = leds_data_4[11];
  400e08:	8ad9      	ldrh	r1, [r3, #22]
  400e0a:	8091      	strh	r1, [r2, #4]

			leds_data_4[9] = 0x1FFF;
  400e0c:	f641 72ff 	movw	r2, #8191	; 0x1fff
  400e10:	825a      	strh	r2, [r3, #18]
			leds_data_4[10] = 0x03FF;
  400e12:	f240 32ff 	movw	r2, #1023	; 0x3ff
  400e16:	829a      	strh	r2, [r3, #20]
			leds_data_4[11] = 0x0000;
  400e18:	2200      	movs	r2, #0
  400e1a:	82da      	strh	r2, [r3, #22]
			break;
	}

	leds_update_display();
  400e1c:	4b04      	ldr	r3, [pc, #16]	; (400e30 <leds_update_cursor+0x33c>)
  400e1e:	4798      	blx	r3
  400e20:	bd08      	pop	{r3, pc}
  400e22:	bf00      	nop
  400e24:	2000003c 	.word	0x2000003c
  400e28:	2000006c 	.word	0x2000006c
  400e2c:	20000054 	.word	0x20000054
  400e30:	00400a29 	.word	0x00400a29

00400e34 <SPI_modeSelect>:
    Mode0		0		1
    Mode1		0		0
    Mode2		1		1
    Mode3		1		0
    */
    if (mode == 0){
  400e34:	b948      	cbnz	r0, 400e4a <SPI_modeSelect+0x16>
        REG_SPI_CSR &= ~SPI_CSR_CPOL;
  400e36:	4b17      	ldr	r3, [pc, #92]	; (400e94 <SPI_modeSelect+0x60>)
  400e38:	681a      	ldr	r2, [r3, #0]
  400e3a:	f022 0201 	bic.w	r2, r2, #1
  400e3e:	601a      	str	r2, [r3, #0]
        REG_SPI_CSR |= SPI_CSR_NCPHA;
  400e40:	681a      	ldr	r2, [r3, #0]
  400e42:	f042 0202 	orr.w	r2, r2, #2
  400e46:	601a      	str	r2, [r3, #0]
  400e48:	4770      	bx	lr
    }
    else if (mode == 1){
  400e4a:	2801      	cmp	r0, #1
  400e4c:	d109      	bne.n	400e62 <SPI_modeSelect+0x2e>
        REG_SPI_CSR &= ~SPI_CSR_CPOL;
  400e4e:	4b11      	ldr	r3, [pc, #68]	; (400e94 <SPI_modeSelect+0x60>)
  400e50:	681a      	ldr	r2, [r3, #0]
  400e52:	f022 0201 	bic.w	r2, r2, #1
  400e56:	601a      	str	r2, [r3, #0]
        REG_SPI_CSR &= ~SPI_CSR_NCPHA;
  400e58:	681a      	ldr	r2, [r3, #0]
  400e5a:	f022 0202 	bic.w	r2, r2, #2
  400e5e:	601a      	str	r2, [r3, #0]
  400e60:	4770      	bx	lr
    }
    else if (mode == 2){
  400e62:	2802      	cmp	r0, #2
  400e64:	d109      	bne.n	400e7a <SPI_modeSelect+0x46>
        REG_SPI_CSR |= SPI_CSR_CPOL;
  400e66:	4b0b      	ldr	r3, [pc, #44]	; (400e94 <SPI_modeSelect+0x60>)
  400e68:	681a      	ldr	r2, [r3, #0]
  400e6a:	f042 0201 	orr.w	r2, r2, #1
  400e6e:	601a      	str	r2, [r3, #0]
        REG_SPI_CSR |= SPI_CSR_NCPHA;
  400e70:	681a      	ldr	r2, [r3, #0]
  400e72:	f042 0202 	orr.w	r2, r2, #2
  400e76:	601a      	str	r2, [r3, #0]
  400e78:	4770      	bx	lr
    }
    else if (mode == 3){
  400e7a:	2803      	cmp	r0, #3
  400e7c:	d108      	bne.n	400e90 <SPI_modeSelect+0x5c>
        REG_SPI_CSR |= SPI_CSR_CPOL;
  400e7e:	4b05      	ldr	r3, [pc, #20]	; (400e94 <SPI_modeSelect+0x60>)
  400e80:	681a      	ldr	r2, [r3, #0]
  400e82:	f042 0201 	orr.w	r2, r2, #1
  400e86:	601a      	str	r2, [r3, #0]
        REG_SPI_CSR &= ~SPI_CSR_NCPHA;
  400e88:	681a      	ldr	r2, [r3, #0]
  400e8a:	f022 0202 	bic.w	r2, r2, #2
  400e8e:	601a      	str	r2, [r3, #0]
  400e90:	4770      	bx	lr
  400e92:	bf00      	nop
  400e94:	40008030 	.word	0x40008030

00400e98 <SPI_led_init>:
    }
}

void SPI_led_init(){
  400e98:	b508      	push	{r3, lr}

	//enable peripheral clock
	REG_PMC_PCER0 |= PMC_PCER0_PID21;
  400e9a:	4a14      	ldr	r2, [pc, #80]	; (400eec <SPI_led_init+0x54>)
  400e9c:	6813      	ldr	r3, [r2, #0]
  400e9e:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
  400ea2:	6013      	str	r3, [r2, #0]

	//set spi master mode
	REG_SPI_MR |= SPI_MR_MSTR;
  400ea4:	4b12      	ldr	r3, [pc, #72]	; (400ef0 <SPI_led_init+0x58>)
  400ea6:	681a      	ldr	r2, [r3, #0]
  400ea8:	f042 0201 	orr.w	r2, r2, #1
  400eac:	601a      	str	r2, [r3, #0]

	//set fixed peripheral select(peripheral chosen in SP_MR.PCS instead of SPI_THR.PCS)
	REG_SPI_MR &= ~SPI_MR_PS;
  400eae:	681a      	ldr	r2, [r3, #0]
  400eb0:	f022 0202 	bic.w	r2, r2, #2
  400eb4:	601a      	str	r2, [r3, #0]
	//REG_SPI_MR |= SPI_MR_PCS(0b1110);

	//set polarity and clock phase to rising edge sample, falling edge shift
	SPI_modeSelect(0);
  400eb6:	2000      	movs	r0, #0
  400eb8:	4b0e      	ldr	r3, [pc, #56]	; (400ef4 <SPI_led_init+0x5c>)
  400eba:	4798      	blx	r3

	//set clock generator (1 = peripheral clock rate), otherwise a divisor
	//SCBR = fperipheral clock / SPCK Bit Rate
	REG_SPI_CSR |= SPI_CSR_SCBR(5);
  400ebc:	4a0e      	ldr	r2, [pc, #56]	; (400ef8 <SPI_led_init+0x60>)
  400ebe:	6813      	ldr	r3, [r2, #0]
  400ec0:	f443 63a0 	orr.w	r3, r3, #1280	; 0x500
  400ec4:	6013      	str	r3, [r2, #0]

	//chip select remains low after transfer
	//REG_SPI_CSR |= SPI_CSR_CSNAAT;

	//give peripheral control of pins 
	REG_PIOA_PDR |= PIO_PDR_P11; //NPCS0
  400ec6:	4b0d      	ldr	r3, [pc, #52]	; (400efc <SPI_led_init+0x64>)
  400ec8:	681a      	ldr	r2, [r3, #0]
  400eca:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
  400ece:	601a      	str	r2, [r3, #0]
	REG_PIOA_PDR |= PIO_PDR_P13; //MOSI
  400ed0:	681a      	ldr	r2, [r3, #0]
  400ed2:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
  400ed6:	601a      	str	r2, [r3, #0]
	REG_PIOA_PDR |= PIO_PDR_P14; //SSCK
  400ed8:	681a      	ldr	r2, [r3, #0]
  400eda:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
  400ede:	601a      	str	r2, [r3, #0]

	//enable SPI
	REG_SPI_CR |= SPI_CR_SPIEN;
  400ee0:	4a07      	ldr	r2, [pc, #28]	; (400f00 <SPI_led_init+0x68>)
  400ee2:	6813      	ldr	r3, [r2, #0]
  400ee4:	f043 0301 	orr.w	r3, r3, #1
  400ee8:	6013      	str	r3, [r2, #0]
  400eea:	bd08      	pop	{r3, pc}
  400eec:	400e0410 	.word	0x400e0410
  400ef0:	40008004 	.word	0x40008004
  400ef4:	00400e35 	.word	0x00400e35
  400ef8:	40008030 	.word	0x40008030
  400efc:	400e0e04 	.word	0x400e0e04
  400f00:	40008000 	.word	0x40008000

00400f04 <SPI_byteSend>:

}

void SPI_byteSend(uint8_t data){
	//wait for transmit register to be empty
	while (!(REG_SPI_SR & SPI_SR_TDRE));
  400f04:	4a04      	ldr	r2, [pc, #16]	; (400f18 <SPI_byteSend+0x14>)
  400f06:	6813      	ldr	r3, [r2, #0]
  400f08:	f013 0f02 	tst.w	r3, #2
  400f0c:	d0fb      	beq.n	400f06 <SPI_byteSend+0x2>
	//send data to transmit register
	REG_SPI_TDR |= (data);
  400f0e:	4a03      	ldr	r2, [pc, #12]	; (400f1c <SPI_byteSend+0x18>)
  400f10:	6813      	ldr	r3, [r2, #0]
  400f12:	4318      	orrs	r0, r3
  400f14:	6010      	str	r0, [r2, #0]
  400f16:	4770      	bx	lr
  400f18:	40008010 	.word	0x40008010
  400f1c:	4000800c 	.word	0x4000800c

00400f20 <timers_init>:
 #include "spi.h"
 #include "dac.h"

 void timers_init(void) {

	overflow_count = 0;
  400f20:	2300      	movs	r3, #0
  400f22:	4a18      	ldr	r2, [pc, #96]	; (400f84 <timers_init+0x64>)
  400f24:	8013      	strh	r3, [r2, #0]
	curr_step = 0;
  400f26:	4a18      	ldr	r2, [pc, #96]	; (400f88 <timers_init+0x68>)
  400f28:	7013      	strb	r3, [r2, #0]
  400f2a:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
  400f2e:	4b17      	ldr	r3, [pc, #92]	; (400f8c <timers_init+0x6c>)
  400f30:	601a      	str	r2, [r3, #0]

	NVIC_EnableIRQ(TC0_IRQn);

	// Enable peripheral clock for TC0
	// Peripheral ID (PID) for TC0 is 23
	REG_PMC_PCER0 |= PMC_PCER0_PID23;
  400f32:	4a17      	ldr	r2, [pc, #92]	; (400f90 <timers_init+0x70>)
  400f34:	6813      	ldr	r3, [r2, #0]
  400f36:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
  400f3a:	6013      	str	r3, [r2, #0]
	// TIMER_CLOCK1 = MCK/2
	// TIMER_CLOCK2 = MCK/8
	// TIMER_CLOCK3 = MCK/32
	// TIMER_CLOCK4 = MCK/128
	// TIMER_CLOCK5 = SCLK
	REG_TC0_CMR0 |= TC_CMR_TCCLKS_TIMER_CLOCK2 | TC_CMR_CPCTRG;
  400f3c:	4915      	ldr	r1, [pc, #84]	; (400f94 <timers_init+0x74>)
  400f3e:	680b      	ldr	r3, [r1, #0]
  400f40:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
  400f44:	f043 0301 	orr.w	r3, r3, #1
  400f48:	600b      	str	r3, [r1, #0]
	// Set interrupt on compare to RC value
	REG_TC0_IER0 |= TC_IER_CPCS;
  400f4a:	3120      	adds	r1, #32
  400f4c:	680b      	ldr	r3, [r1, #0]
  400f4e:	f043 0310 	orr.w	r3, r3, #16
  400f52:	600b      	str	r3, [r1, #0]
// 	// 60 BPM = 1 Hz. SCK = 32 KHz. 16,000 counts per half second, 2 interrupts per cycle
// 	REG_TC0_RC0 = 16000;

	// 60 BPM = 1 Hz. MCK/8 = 12.5 MHz. 6.25 mil counts per half second, 2 interrupts per cycle
	// Anticipating 5000 overflows (5000*1250 is 6.25 mil)
	REG_TC0_RC0 = 1250;
  400f54:	f240 41e2 	movw	r1, #1250	; 0x4e2
  400f58:	4b0f      	ldr	r3, [pc, #60]	; (400f98 <timers_init+0x78>)
  400f5a:	6019      	str	r1, [r3, #0]

	// For the interrupt
	REG_PIOA_PER |= PIO_PER_P20; //enable PIO controller on PA11
  400f5c:	490f      	ldr	r1, [pc, #60]	; (400f9c <timers_init+0x7c>)
  400f5e:	680b      	ldr	r3, [r1, #0]
  400f60:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
  400f64:	600b      	str	r3, [r1, #0]
	REG_PIOA_OER |= PIO_PER_P20; //enable output on pin PA11
  400f66:	3110      	adds	r1, #16
  400f68:	680b      	ldr	r3, [r1, #0]
  400f6a:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
  400f6e:	600b      	str	r3, [r1, #0]
	REG_PMC_PCER0 |= PMC_PCER0_PID11; //Enable PMC control for PA11
  400f70:	6813      	ldr	r3, [r2, #0]
  400f72:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
  400f76:	6013      	str	r3, [r2, #0]

	// TC0 control register enables timer and triggers it to start
	REG_TC0_CCR0 |= TC_CCR_CLKEN | TC_CCR_SWTRG;
  400f78:	4a09      	ldr	r2, [pc, #36]	; (400fa0 <timers_init+0x80>)
  400f7a:	6813      	ldr	r3, [r2, #0]
  400f7c:	f043 0305 	orr.w	r3, r3, #5
  400f80:	6013      	str	r3, [r2, #0]
  400f82:	4770      	bx	lr
  400f84:	200004c6 	.word	0x200004c6
  400f88:	200004c8 	.word	0x200004c8
  400f8c:	e000e100 	.word	0xe000e100
  400f90:	400e0410 	.word	0x400e0410
  400f94:	40010004 	.word	0x40010004
  400f98:	4001001c 	.word	0x4001001c
  400f9c:	400e0e00 	.word	0x400e0e00
  400fa0:	40010000 	.word	0x40010000

00400fa4 <update_timers>:

 void update_timers(int bpm) {
// 	// (SCK/2) / (bpm/60); SCK*60/2 = 960000
// 	// Offset is needed, possible not with the crystals working
// 	REG_TC0_RC0 = (uint16_t)(960000/bpm - 420);
	if(bpm > 1) {
  400fa4:	2801      	cmp	r0, #1
  400fa6:	dd05      	ble.n	400fb4 <update_timers+0x10>
		REG_TC0_RC0 = (uint16_t)(75000/bpm);
  400fa8:	4b03      	ldr	r3, [pc, #12]	; (400fb8 <update_timers+0x14>)
  400faa:	fb93 f0f0 	sdiv	r0, r3, r0
  400fae:	b280      	uxth	r0, r0
  400fb0:	4b02      	ldr	r3, [pc, #8]	; (400fbc <update_timers+0x18>)
  400fb2:	6018      	str	r0, [r3, #0]
  400fb4:	4770      	bx	lr
  400fb6:	bf00      	nop
  400fb8:	000124f8 	.word	0x000124f8
  400fbc:	4001001c 	.word	0x4001001c

00400fc0 <TC0_Handler>:

 void TC0_Handler() {
	 // Handling timer = RC

	 // Test code, normally trigger next step, output clock
	 if((REG_TC0_SR0 & TC_SR_CPCS) >= 0) {
  400fc0:	4b0f      	ldr	r3, [pc, #60]	; (401000 <TC0_Handler+0x40>)
  400fc2:	681b      	ldr	r3, [r3, #0]
		overflow_count += 1;
  400fc4:	4a0f      	ldr	r2, [pc, #60]	; (401004 <TC0_Handler+0x44>)
  400fc6:	8813      	ldrh	r3, [r2, #0]
  400fc8:	3301      	adds	r3, #1
  400fca:	b29b      	uxth	r3, r3
  400fcc:	8013      	strh	r3, [r2, #0]
		if (overflow_count == 9000){
			/*DAC_write_gate_off();*/
		}
	 }

	 if(overflow_count >= 10000) {
  400fce:	f242 720f 	movw	r2, #9999	; 0x270f
  400fd2:	4293      	cmp	r3, r2
  400fd4:	d913      	bls.n	400ffe <TC0_Handler+0x3e>
	if(bpm > 1) {
		REG_TC0_RC0 = (uint16_t)(75000/bpm);
	}
 }

 void TC0_Handler() {
  400fd6:	b510      	push	{r4, lr}
		}
	 }

	 if(overflow_count >= 10000) {

		SPI_led_init();
  400fd8:	4b0b      	ldr	r3, [pc, #44]	; (401008 <TC0_Handler+0x48>)
  400fda:	4798      	blx	r3
		leds_update_cursor(curr_step);
  400fdc:	4c0b      	ldr	r4, [pc, #44]	; (40100c <TC0_Handler+0x4c>)
  400fde:	7820      	ldrb	r0, [r4, #0]
  400fe0:	4b0b      	ldr	r3, [pc, #44]	; (401010 <TC0_Handler+0x50>)
  400fe2:	4798      	blx	r3
// 		if (notes_status[curr_step] == 1){
// 			DAC_write_gate_on();
// 		}
		

		if (curr_step == 15){
  400fe4:	7823      	ldrb	r3, [r4, #0]
  400fe6:	2b0f      	cmp	r3, #15
  400fe8:	d102      	bne.n	400ff0 <TC0_Handler+0x30>
			curr_step = 0;
  400fea:	2200      	movs	r2, #0
  400fec:	7022      	strb	r2, [r4, #0]
  400fee:	e002      	b.n	400ff6 <TC0_Handler+0x36>
		}
		else{
			curr_step++;
  400ff0:	3301      	adds	r3, #1
  400ff2:	4a06      	ldr	r2, [pc, #24]	; (40100c <TC0_Handler+0x4c>)
  400ff4:	7013      	strb	r3, [r2, #0]
		}

		overflow_count = 0;
  400ff6:	2200      	movs	r2, #0
  400ff8:	4b02      	ldr	r3, [pc, #8]	; (401004 <TC0_Handler+0x44>)
  400ffa:	801a      	strh	r2, [r3, #0]
  400ffc:	bd10      	pop	{r4, pc}
  400ffe:	4770      	bx	lr
  401000:	40010020 	.word	0x40010020
  401004:	200004c6 	.word	0x200004c6
  401008:	00400e99 	.word	0x00400e99
  40100c:	200004c8 	.word	0x200004c8
  401010:	00400af5 	.word	0x00400af5

00401014 <board_init>:
#include <asf.h>
#include <board.h>
#include <conf_board.h>

void board_init(void)
{
  401014:	4770      	bx	lr
  401016:	bf00      	nop

00401018 <sysclk_init>:

	SystemCoreClockUpdate();
}

void sysclk_init(void)
{
  401018:	b510      	push	{r4, lr}
	/* Set flash wait state to max in case the below clock switching. */
	system_init_flash(CHIP_FREQ_CPU_MAX);
  40101a:	480e      	ldr	r0, [pc, #56]	; (401054 <sysclk_init+0x3c>)
  40101c:	4b0e      	ldr	r3, [pc, #56]	; (401058 <sysclk_init+0x40>)
  40101e:	4798      	blx	r3
	case OSC_MAINCK_4M_RC:
		pmc_switch_mainck_to_fastrc(CKGR_MOR_MOSCRCF_4_MHz);
		break;

	case OSC_MAINCK_8M_RC:
		pmc_switch_mainck_to_fastrc(CKGR_MOR_MOSCRCF_8_MHz);
  401020:	2010      	movs	r0, #16
  401022:	4b0e      	ldr	r3, [pc, #56]	; (40105c <sysclk_init+0x44>)
  401024:	4798      	blx	r3
	case OSC_MAINCK_4M_RC:
	case OSC_MAINCK_8M_RC:
	case OSC_MAINCK_12M_RC:
	case OSC_MAINCK_XTAL:
	case OSC_MAINCK_BYPASS:
		return pmc_osc_is_ready_mainck();
  401026:	4c0e      	ldr	r4, [pc, #56]	; (401060 <sysclk_init+0x48>)
  401028:	47a0      	blx	r4
 *
 * \param id A number identifying the oscillator to wait for.
 */
static inline void osc_wait_ready(uint8_t id)
{
	while (!osc_is_ready(id)) {
  40102a:	2800      	cmp	r0, #0
  40102c:	d0fc      	beq.n	401028 <sysclk_init+0x10>
static inline void pll_enable(const struct pll_config *p_cfg, uint32_t ul_pll_id)
{
	Assert(ul_pll_id < NR_PLLS);

	if (ul_pll_id == PLLA_ID) {
		pmc_disable_pllack(); // Always stop PLL first!
  40102e:	4b0d      	ldr	r3, [pc, #52]	; (401064 <sysclk_init+0x4c>)
  401030:	4798      	blx	r3
		PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | p_cfg->ctrl;
  401032:	4a0d      	ldr	r2, [pc, #52]	; (401068 <sysclk_init+0x50>)
  401034:	4b0d      	ldr	r3, [pc, #52]	; (40106c <sysclk_init+0x54>)
  401036:	629a      	str	r2, [r3, #40]	; 0x28
static inline uint32_t pll_is_locked(uint32_t ul_pll_id)
{
	Assert(ul_pll_id < NR_PLLS);

	if (ul_pll_id == PLLA_ID) {
		return pmc_is_locked_pllack();
  401038:	4c0d      	ldr	r4, [pc, #52]	; (401070 <sysclk_init+0x58>)
  40103a:	47a0      	blx	r4
 */
static inline int pll_wait_for_lock(unsigned int pll_id)
{
	Assert(pll_id < NR_PLLS);

	while (!pll_is_locked(pll_id)) {
  40103c:	2800      	cmp	r0, #0
  40103e:	d0fc      	beq.n	40103a <sysclk_init+0x22>

		pll_enable_source(CONFIG_PLL0_SOURCE);
		pll_config_defaults(&pllcfg, 0);
		pll_enable(&pllcfg, 0);
		pll_wait_for_lock(0);
		pmc_switch_mck_to_pllack(CONFIG_SYSCLK_PRES);
  401040:	2010      	movs	r0, #16
  401042:	4b0c      	ldr	r3, [pc, #48]	; (401074 <sysclk_init+0x5c>)
  401044:	4798      	blx	r3
	}
#endif

	/* Update the SystemFrequency variable */
	SystemCoreClockUpdate();
  401046:	4b0c      	ldr	r3, [pc, #48]	; (401078 <sysclk_init+0x60>)
  401048:	4798      	blx	r3

	/* Set a flash wait state depending on the new cpu frequency */
	system_init_flash(sysclk_get_cpu_hz());
  40104a:	4802      	ldr	r0, [pc, #8]	; (401054 <sysclk_init+0x3c>)
  40104c:	4b02      	ldr	r3, [pc, #8]	; (401058 <sysclk_init+0x40>)
  40104e:	4798      	blx	r3
  401050:	bd10      	pop	{r4, pc}
  401052:	bf00      	nop
  401054:	05f5e100 	.word	0x05f5e100
  401058:	0040130d 	.word	0x0040130d
  40105c:	004010e5 	.word	0x004010e5
  401060:	00401131 	.word	0x00401131
  401064:	00401141 	.word	0x00401141
  401068:	20183f01 	.word	0x20183f01
  40106c:	400e0400 	.word	0x400e0400
  401070:	00401151 	.word	0x00401151
  401074:	0040107d 	.word	0x0040107d
  401078:	004011fd 	.word	0x004011fd

0040107c <pmc_switch_mck_to_pllack>:
 */
uint32_t pmc_switch_mck_to_pllack(uint32_t ul_pres)
{
	uint32_t ul_timeout;

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
  40107c:	4a18      	ldr	r2, [pc, #96]	; (4010e0 <pmc_switch_mck_to_pllack+0x64>)
  40107e:	6b13      	ldr	r3, [r2, #48]	; 0x30
  401080:	f023 0370 	bic.w	r3, r3, #112	; 0x70
  401084:	4318      	orrs	r0, r3
  401086:	6310      	str	r0, [r2, #48]	; 0x30
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  401088:	6e93      	ldr	r3, [r2, #104]	; 0x68
  40108a:	f013 0f08 	tst.w	r3, #8
  40108e:	d003      	beq.n	401098 <pmc_switch_mck_to_pllack+0x1c>
  401090:	e009      	b.n	4010a6 <pmc_switch_mck_to_pllack+0x2a>
			--ul_timeout) {
		if (ul_timeout == 0) {
  401092:	3b01      	subs	r3, #1
  401094:	d103      	bne.n	40109e <pmc_switch_mck_to_pllack+0x22>
  401096:	e01e      	b.n	4010d6 <pmc_switch_mck_to_pllack+0x5a>
uint32_t pmc_switch_mck_to_pllack(uint32_t ul_pres)
{
	uint32_t ul_timeout;

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  401098:	f44f 6300 	mov.w	r3, #2048	; 0x800
  40109c:	4910      	ldr	r1, [pc, #64]	; (4010e0 <pmc_switch_mck_to_pllack+0x64>)
  40109e:	6e8a      	ldr	r2, [r1, #104]	; 0x68
  4010a0:	f012 0f08 	tst.w	r2, #8
  4010a4:	d0f5      	beq.n	401092 <pmc_switch_mck_to_pllack+0x16>
		if (ul_timeout == 0) {
			return 1;
		}
	}

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) |
  4010a6:	4a0e      	ldr	r2, [pc, #56]	; (4010e0 <pmc_switch_mck_to_pllack+0x64>)
  4010a8:	6b13      	ldr	r3, [r2, #48]	; 0x30
  4010aa:	f023 0303 	bic.w	r3, r3, #3
  4010ae:	f043 0302 	orr.w	r3, r3, #2
  4010b2:	6313      	str	r3, [r2, #48]	; 0x30
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  4010b4:	6e90      	ldr	r0, [r2, #104]	; 0x68
  4010b6:	f010 0008 	ands.w	r0, r0, #8
  4010ba:	d004      	beq.n	4010c6 <pmc_switch_mck_to_pllack+0x4a>
		if (ul_timeout == 0) {
			return 1;
		}
	}

	return 0;
  4010bc:	2000      	movs	r0, #0
  4010be:	4770      	bx	lr
	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) |
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
			--ul_timeout) {
		if (ul_timeout == 0) {
  4010c0:	3b01      	subs	r3, #1
  4010c2:	d103      	bne.n	4010cc <pmc_switch_mck_to_pllack+0x50>
  4010c4:	e009      	b.n	4010da <pmc_switch_mck_to_pllack+0x5e>
	}

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) |
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  4010c6:	f44f 6300 	mov.w	r3, #2048	; 0x800
  4010ca:	4905      	ldr	r1, [pc, #20]	; (4010e0 <pmc_switch_mck_to_pllack+0x64>)
  4010cc:	6e8a      	ldr	r2, [r1, #104]	; 0x68
  4010ce:	f012 0f08 	tst.w	r2, #8
  4010d2:	d0f5      	beq.n	4010c0 <pmc_switch_mck_to_pllack+0x44>
  4010d4:	4770      	bx	lr

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
			--ul_timeout) {
		if (ul_timeout == 0) {
			return 1;
  4010d6:	2001      	movs	r0, #1
  4010d8:	4770      	bx	lr
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
			--ul_timeout) {
		if (ul_timeout == 0) {
			return 1;
  4010da:	2001      	movs	r0, #1
		}
	}

	return 0;
}
  4010dc:	4770      	bx	lr
  4010de:	bf00      	nop
  4010e0:	400e0400 	.word	0x400e0400

004010e4 <pmc_switch_mainck_to_fastrc>:
 * \retval 2 Invalid frequency.
 */
void pmc_switch_mainck_to_fastrc(uint32_t ul_moscrcf)
{
	/* Enable Fast RC oscillator but DO NOT switch to RC now */
	PMC->CKGR_MOR |= (CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCRCEN);
  4010e4:	4b11      	ldr	r3, [pc, #68]	; (40112c <pmc_switch_mainck_to_fastrc+0x48>)
  4010e6:	6a1a      	ldr	r2, [r3, #32]
  4010e8:	f442 125c 	orr.w	r2, r2, #3604480	; 0x370000
  4010ec:	f042 0208 	orr.w	r2, r2, #8
  4010f0:	621a      	str	r2, [r3, #32]

	/* Wait the Fast RC to stabilize */
	while (!(PMC->PMC_SR & PMC_SR_MOSCRCS));
  4010f2:	461a      	mov	r2, r3
  4010f4:	6e93      	ldr	r3, [r2, #104]	; 0x68
  4010f6:	f413 3f00 	tst.w	r3, #131072	; 0x20000
  4010fa:	d0fb      	beq.n	4010f4 <pmc_switch_mainck_to_fastrc+0x10>

	/* Change Fast RC oscillator frequency */
	PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCRCF_Msk) |
  4010fc:	4a0b      	ldr	r2, [pc, #44]	; (40112c <pmc_switch_mainck_to_fastrc+0x48>)
  4010fe:	6a13      	ldr	r3, [r2, #32]
			CKGR_MOR_KEY_PASSWD | ul_moscrcf;
  401100:	f423 135c 	bic.w	r3, r3, #3604480	; 0x370000
  401104:	f023 0370 	bic.w	r3, r3, #112	; 0x70
  401108:	f443 135c 	orr.w	r3, r3, #3604480	; 0x370000
  40110c:	4303      	orrs	r3, r0

	/* Wait the Fast RC to stabilize */
	while (!(PMC->PMC_SR & PMC_SR_MOSCRCS));

	/* Change Fast RC oscillator frequency */
	PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCRCF_Msk) |
  40110e:	6213      	str	r3, [r2, #32]
			CKGR_MOR_KEY_PASSWD | ul_moscrcf;

	/* Wait the Fast RC to stabilize */
	while (!(PMC->PMC_SR & PMC_SR_MOSCRCS));
  401110:	6e93      	ldr	r3, [r2, #104]	; 0x68
  401112:	f413 3f00 	tst.w	r3, #131072	; 0x20000
  401116:	d0fb      	beq.n	401110 <pmc_switch_mainck_to_fastrc+0x2c>

	/* Switch to Fast RC */
	PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCSEL) |
  401118:	4a04      	ldr	r2, [pc, #16]	; (40112c <pmc_switch_mainck_to_fastrc+0x48>)
  40111a:	6a13      	ldr	r3, [r2, #32]
  40111c:	f023 739b 	bic.w	r3, r3, #20316160	; 0x1360000
  401120:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
  401124:	f443 135c 	orr.w	r3, r3, #3604480	; 0x370000
  401128:	6213      	str	r3, [r2, #32]
  40112a:	4770      	bx	lr
  40112c:	400e0400 	.word	0x400e0400

00401130 <pmc_osc_is_ready_mainck>:
 * \retval 1 Xtal is ready.
 * \retval 0 Xtal is not ready.
 */
uint32_t pmc_osc_is_ready_mainck(void)
{
	return PMC->PMC_SR & PMC_SR_MOSCSELS;
  401130:	4b02      	ldr	r3, [pc, #8]	; (40113c <pmc_osc_is_ready_mainck+0xc>)
  401132:	6e98      	ldr	r0, [r3, #104]	; 0x68
}
  401134:	f400 3080 	and.w	r0, r0, #65536	; 0x10000
  401138:	4770      	bx	lr
  40113a:	bf00      	nop
  40113c:	400e0400 	.word	0x400e0400

00401140 <pmc_disable_pllack>:
void pmc_disable_pllack(void)
{
#if (SAM4C || SAM4CM || SAM4CP || SAMG)
	PMC->CKGR_PLLAR = CKGR_PLLAR_MULA(0);
#else
	PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | CKGR_PLLAR_MULA(0);
  401140:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
  401144:	4b01      	ldr	r3, [pc, #4]	; (40114c <pmc_disable_pllack+0xc>)
  401146:	629a      	str	r2, [r3, #40]	; 0x28
  401148:	4770      	bx	lr
  40114a:	bf00      	nop
  40114c:	400e0400 	.word	0x400e0400

00401150 <pmc_is_locked_pllack>:
 * \retval 0 Not locked.
 * \retval 1 Locked.
 */
uint32_t pmc_is_locked_pllack(void)
{
	return (PMC->PMC_SR & PMC_SR_LOCKA);
  401150:	4b02      	ldr	r3, [pc, #8]	; (40115c <pmc_is_locked_pllack+0xc>)
  401152:	6e98      	ldr	r0, [r3, #104]	; 0x68
}
  401154:	f000 0002 	and.w	r0, r0, #2
  401158:	4770      	bx	lr
  40115a:	bf00      	nop
  40115c:	400e0400 	.word	0x400e0400

00401160 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
  401160:	e7fe      	b.n	401160 <Dummy_Handler>
  401162:	bf00      	nop

00401164 <Reset_Handler>:
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
{
  401164:	b508      	push	{r3, lr}

	/* Initialize the relocate segment */
	pSrc = &_etext;
	pDest = &_srelocate;

	if (pSrc != pDest) {
  401166:	4b19      	ldr	r3, [pc, #100]	; (4011cc <Reset_Handler+0x68>)
  401168:	4a19      	ldr	r2, [pc, #100]	; (4011d0 <Reset_Handler+0x6c>)
  40116a:	429a      	cmp	r2, r3
  40116c:	d003      	beq.n	401176 <Reset_Handler+0x12>
		for (; pDest < &_erelocate;) {
  40116e:	4b19      	ldr	r3, [pc, #100]	; (4011d4 <Reset_Handler+0x70>)
  401170:	4a16      	ldr	r2, [pc, #88]	; (4011cc <Reset_Handler+0x68>)
  401172:	429a      	cmp	r2, r3
  401174:	d304      	bcc.n	401180 <Reset_Handler+0x1c>
			*pDest++ = *pSrc++;
		}
	}

	/* Clear the zero segment */
	for (pDest = &_szero; pDest < &_ezero;) {
  401176:	4b18      	ldr	r3, [pc, #96]	; (4011d8 <Reset_Handler+0x74>)
  401178:	4a18      	ldr	r2, [pc, #96]	; (4011dc <Reset_Handler+0x78>)
  40117a:	429a      	cmp	r2, r3
  40117c:	d30f      	bcc.n	40119e <Reset_Handler+0x3a>
  40117e:	e01a      	b.n	4011b6 <Reset_Handler+0x52>
  401180:	4912      	ldr	r1, [pc, #72]	; (4011cc <Reset_Handler+0x68>)
  401182:	4b17      	ldr	r3, [pc, #92]	; (4011e0 <Reset_Handler+0x7c>)
  401184:	1a5b      	subs	r3, r3, r1
  401186:	f023 0303 	bic.w	r3, r3, #3
  40118a:	3304      	adds	r3, #4
  40118c:	4a10      	ldr	r2, [pc, #64]	; (4011d0 <Reset_Handler+0x6c>)
  40118e:	4413      	add	r3, r2
	pSrc = &_etext;
	pDest = &_srelocate;

	if (pSrc != pDest) {
		for (; pDest < &_erelocate;) {
			*pDest++ = *pSrc++;
  401190:	f852 0b04 	ldr.w	r0, [r2], #4
  401194:	f841 0b04 	str.w	r0, [r1], #4
	/* Initialize the relocate segment */
	pSrc = &_etext;
	pDest = &_srelocate;

	if (pSrc != pDest) {
		for (; pDest < &_erelocate;) {
  401198:	429a      	cmp	r2, r3
  40119a:	d1f9      	bne.n	401190 <Reset_Handler+0x2c>
  40119c:	e7eb      	b.n	401176 <Reset_Handler+0x12>
  40119e:	4b11      	ldr	r3, [pc, #68]	; (4011e4 <Reset_Handler+0x80>)
  4011a0:	4a11      	ldr	r2, [pc, #68]	; (4011e8 <Reset_Handler+0x84>)
  4011a2:	1ad2      	subs	r2, r2, r3
  4011a4:	f022 0203 	bic.w	r2, r2, #3
  4011a8:	441a      	add	r2, r3
			*pDest++ = *pSrc++;
		}
	}

	/* Clear the zero segment */
	for (pDest = &_szero; pDest < &_ezero;) {
  4011aa:	3b04      	subs	r3, #4
		*pDest++ = 0;
  4011ac:	2100      	movs	r1, #0
  4011ae:	f843 1b04 	str.w	r1, [r3], #4
			*pDest++ = *pSrc++;
		}
	}

	/* Clear the zero segment */
	for (pDest = &_szero; pDest < &_ezero;) {
  4011b2:	4293      	cmp	r3, r2
  4011b4:	d1fb      	bne.n	4011ae <Reset_Handler+0x4a>
		*pDest++ = 0;
	}

	/* Set the vector table base address */
	pSrc = (uint32_t *) & _sfixed;
	SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
  4011b6:	4a0d      	ldr	r2, [pc, #52]	; (4011ec <Reset_Handler+0x88>)
  4011b8:	4b0d      	ldr	r3, [pc, #52]	; (4011f0 <Reset_Handler+0x8c>)
  4011ba:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
  4011be:	6093      	str	r3, [r2, #8]

	/* Initialize the C library */
	__libc_init_array();
  4011c0:	4b0c      	ldr	r3, [pc, #48]	; (4011f4 <Reset_Handler+0x90>)
  4011c2:	4798      	blx	r3

	/* Branch to main function */
	main();
  4011c4:	4b0c      	ldr	r3, [pc, #48]	; (4011f8 <Reset_Handler+0x94>)
  4011c6:	4798      	blx	r3
  4011c8:	e7fe      	b.n	4011c8 <Reset_Handler+0x64>
  4011ca:	bf00      	nop
  4011cc:	20000000 	.word	0x20000000
  4011d0:	004016d8 	.word	0x004016d8
  4011d4:	200004a8 	.word	0x200004a8
  4011d8:	200004cc 	.word	0x200004cc
  4011dc:	200004a8 	.word	0x200004a8
  4011e0:	200004a7 	.word	0x200004a7
  4011e4:	200004ac 	.word	0x200004ac
  4011e8:	200004cf 	.word	0x200004cf
  4011ec:	e000ed00 	.word	0xe000ed00
  4011f0:	00400000 	.word	0x00400000
  4011f4:	00401571 	.word	0x00401571
  4011f8:	004014c1 	.word	0x004014c1

004011fc <SystemCoreClockUpdate>:
}

void SystemCoreClockUpdate(void)
{
	/* Determine clock frequency according to clock register values */
	switch (PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk) {
  4011fc:	4b3c      	ldr	r3, [pc, #240]	; (4012f0 <SystemCoreClockUpdate+0xf4>)
  4011fe:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  401200:	f003 0303 	and.w	r3, r3, #3
  401204:	2b01      	cmp	r3, #1
  401206:	d00f      	beq.n	401228 <SystemCoreClockUpdate+0x2c>
  401208:	b113      	cbz	r3, 401210 <SystemCoreClockUpdate+0x14>
  40120a:	2b02      	cmp	r3, #2
  40120c:	d029      	beq.n	401262 <SystemCoreClockUpdate+0x66>
  40120e:	e057      	b.n	4012c0 <SystemCoreClockUpdate+0xc4>
	case PMC_MCKR_CSS_SLOW_CLK:	/* Slow clock */
		if (SUPC->SUPC_SR & SUPC_SR_OSCSEL) {
  401210:	4b38      	ldr	r3, [pc, #224]	; (4012f4 <SystemCoreClockUpdate+0xf8>)
  401212:	695b      	ldr	r3, [r3, #20]
  401214:	f013 0f80 	tst.w	r3, #128	; 0x80
			SystemCoreClock = CHIP_FREQ_XTAL_32K;
  401218:	bf14      	ite	ne
  40121a:	f44f 4200 	movne.w	r2, #32768	; 0x8000
		} else {
			SystemCoreClock = CHIP_FREQ_SLCK_RC;
  40121e:	f44f 42fa 	moveq.w	r2, #32000	; 0x7d00
  401222:	4b35      	ldr	r3, [pc, #212]	; (4012f8 <SystemCoreClockUpdate+0xfc>)
  401224:	601a      	str	r2, [r3, #0]
  401226:	e04b      	b.n	4012c0 <SystemCoreClockUpdate+0xc4>
		}
		break;

	case PMC_MCKR_CSS_MAIN_CLK:	/* Main clock */
		if (PMC->CKGR_MOR & CKGR_MOR_MOSCSEL) {
  401228:	4b31      	ldr	r3, [pc, #196]	; (4012f0 <SystemCoreClockUpdate+0xf4>)
  40122a:	6a1b      	ldr	r3, [r3, #32]
  40122c:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
  401230:	d003      	beq.n	40123a <SystemCoreClockUpdate+0x3e>
			SystemCoreClock = CHIP_FREQ_XTAL_12M;
  401232:	4a32      	ldr	r2, [pc, #200]	; (4012fc <SystemCoreClockUpdate+0x100>)
  401234:	4b30      	ldr	r3, [pc, #192]	; (4012f8 <SystemCoreClockUpdate+0xfc>)
  401236:	601a      	str	r2, [r3, #0]
  401238:	e042      	b.n	4012c0 <SystemCoreClockUpdate+0xc4>
		} else {
			SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
  40123a:	4a31      	ldr	r2, [pc, #196]	; (401300 <SystemCoreClockUpdate+0x104>)
  40123c:	4b2e      	ldr	r3, [pc, #184]	; (4012f8 <SystemCoreClockUpdate+0xfc>)
  40123e:	601a      	str	r2, [r3, #0]

			switch (PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk) {
  401240:	4b2b      	ldr	r3, [pc, #172]	; (4012f0 <SystemCoreClockUpdate+0xf4>)
  401242:	6a1b      	ldr	r3, [r3, #32]
  401244:	f003 0370 	and.w	r3, r3, #112	; 0x70
  401248:	2b10      	cmp	r3, #16
  40124a:	d002      	beq.n	401252 <SystemCoreClockUpdate+0x56>
  40124c:	2b20      	cmp	r3, #32
  40124e:	d004      	beq.n	40125a <SystemCoreClockUpdate+0x5e>
  401250:	e036      	b.n	4012c0 <SystemCoreClockUpdate+0xc4>
			case CKGR_MOR_MOSCRCF_4_MHz:
				break;

			case CKGR_MOR_MOSCRCF_8_MHz:
				SystemCoreClock *= 2U;
  401252:	4a2c      	ldr	r2, [pc, #176]	; (401304 <SystemCoreClockUpdate+0x108>)
  401254:	4b28      	ldr	r3, [pc, #160]	; (4012f8 <SystemCoreClockUpdate+0xfc>)
  401256:	601a      	str	r2, [r3, #0]
				break;
  401258:	e032      	b.n	4012c0 <SystemCoreClockUpdate+0xc4>

			case CKGR_MOR_MOSCRCF_12_MHz:
				SystemCoreClock *= 3U;
  40125a:	4a28      	ldr	r2, [pc, #160]	; (4012fc <SystemCoreClockUpdate+0x100>)
  40125c:	4b26      	ldr	r3, [pc, #152]	; (4012f8 <SystemCoreClockUpdate+0xfc>)
  40125e:	601a      	str	r2, [r3, #0]
				break;
  401260:	e02e      	b.n	4012c0 <SystemCoreClockUpdate+0xc4>
			}
		}
		break;

	case PMC_MCKR_CSS_PLLA_CLK:	/* PLLA clock */
		if (PMC->CKGR_MOR & CKGR_MOR_MOSCSEL) {
  401262:	4b23      	ldr	r3, [pc, #140]	; (4012f0 <SystemCoreClockUpdate+0xf4>)
  401264:	6a1b      	ldr	r3, [r3, #32]
  401266:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
  40126a:	d003      	beq.n	401274 <SystemCoreClockUpdate+0x78>
			SystemCoreClock = CHIP_FREQ_XTAL_12M;
  40126c:	4a23      	ldr	r2, [pc, #140]	; (4012fc <SystemCoreClockUpdate+0x100>)
  40126e:	4b22      	ldr	r3, [pc, #136]	; (4012f8 <SystemCoreClockUpdate+0xfc>)
  401270:	601a      	str	r2, [r3, #0]
  401272:	e012      	b.n	40129a <SystemCoreClockUpdate+0x9e>
		} else {
			SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
  401274:	4a22      	ldr	r2, [pc, #136]	; (401300 <SystemCoreClockUpdate+0x104>)
  401276:	4b20      	ldr	r3, [pc, #128]	; (4012f8 <SystemCoreClockUpdate+0xfc>)
  401278:	601a      	str	r2, [r3, #0]

			switch (PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk) {
  40127a:	4b1d      	ldr	r3, [pc, #116]	; (4012f0 <SystemCoreClockUpdate+0xf4>)
  40127c:	6a1b      	ldr	r3, [r3, #32]
  40127e:	f003 0370 	and.w	r3, r3, #112	; 0x70
  401282:	2b10      	cmp	r3, #16
  401284:	d002      	beq.n	40128c <SystemCoreClockUpdate+0x90>
  401286:	2b20      	cmp	r3, #32
  401288:	d004      	beq.n	401294 <SystemCoreClockUpdate+0x98>
  40128a:	e006      	b.n	40129a <SystemCoreClockUpdate+0x9e>
				/* So the 4MHz RC selection is forbidden */
				Assert(false);
				break;

			case CKGR_MOR_MOSCRCF_8_MHz:
				SystemCoreClock *= 2U;
  40128c:	4a1d      	ldr	r2, [pc, #116]	; (401304 <SystemCoreClockUpdate+0x108>)
  40128e:	4b1a      	ldr	r3, [pc, #104]	; (4012f8 <SystemCoreClockUpdate+0xfc>)
  401290:	601a      	str	r2, [r3, #0]
				break;
  401292:	e002      	b.n	40129a <SystemCoreClockUpdate+0x9e>

			case CKGR_MOR_MOSCRCF_12_MHz:
				SystemCoreClock *= 3U;
  401294:	4a19      	ldr	r2, [pc, #100]	; (4012fc <SystemCoreClockUpdate+0x100>)
  401296:	4b18      	ldr	r3, [pc, #96]	; (4012f8 <SystemCoreClockUpdate+0xfc>)
  401298:	601a      	str	r2, [r3, #0]
			default:
				break;
			}
		}

		if ((uint32_t) (PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk) ==
  40129a:	4b15      	ldr	r3, [pc, #84]	; (4012f0 <SystemCoreClockUpdate+0xf4>)
  40129c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  40129e:	f003 0303 	and.w	r3, r3, #3
  4012a2:	2b02      	cmp	r3, #2
  4012a4:	d10c      	bne.n	4012c0 <SystemCoreClockUpdate+0xc4>
				PMC_MCKR_CSS_PLLA_CLK) {
			SystemCoreClock *=
					((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk)
  4012a6:	4a12      	ldr	r2, [pc, #72]	; (4012f0 <SystemCoreClockUpdate+0xf4>)
  4012a8:	6a93      	ldr	r3, [r2, #40]	; 0x28
					>> CKGR_PLLAR_MULA_Pos) + 1U);
			SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk)
  4012aa:	6a92      	ldr	r2, [r2, #40]	; 0x28
  4012ac:	4812      	ldr	r0, [pc, #72]	; (4012f8 <SystemCoreClockUpdate+0xfc>)
  4012ae:	f3c3 410a 	ubfx	r1, r3, #16, #11
  4012b2:	6803      	ldr	r3, [r0, #0]
  4012b4:	fb01 3303 	mla	r3, r1, r3, r3
  4012b8:	b2d2      	uxtb	r2, r2
  4012ba:	fbb3 f3f2 	udiv	r3, r3, r2
  4012be:	6003      	str	r3, [r0, #0]

	default:
		break;
	}

	if ((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) == PMC_MCKR_PRES_CLK_3) {
  4012c0:	4b0b      	ldr	r3, [pc, #44]	; (4012f0 <SystemCoreClockUpdate+0xf4>)
  4012c2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4012c4:	f003 0370 	and.w	r3, r3, #112	; 0x70
  4012c8:	2b70      	cmp	r3, #112	; 0x70
  4012ca:	d107      	bne.n	4012dc <SystemCoreClockUpdate+0xe0>
		SystemCoreClock /= 3U;
  4012cc:	4a0a      	ldr	r2, [pc, #40]	; (4012f8 <SystemCoreClockUpdate+0xfc>)
  4012ce:	6813      	ldr	r3, [r2, #0]
  4012d0:	490d      	ldr	r1, [pc, #52]	; (401308 <SystemCoreClockUpdate+0x10c>)
  4012d2:	fba1 1303 	umull	r1, r3, r1, r3
  4012d6:	085b      	lsrs	r3, r3, #1
  4012d8:	6013      	str	r3, [r2, #0]
  4012da:	4770      	bx	lr
	} else {
		SystemCoreClock >>= ((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) >>
  4012dc:	4b04      	ldr	r3, [pc, #16]	; (4012f0 <SystemCoreClockUpdate+0xf4>)
  4012de:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4012e0:	4905      	ldr	r1, [pc, #20]	; (4012f8 <SystemCoreClockUpdate+0xfc>)
  4012e2:	f3c3 1202 	ubfx	r2, r3, #4, #3
  4012e6:	680b      	ldr	r3, [r1, #0]
  4012e8:	40d3      	lsrs	r3, r2
  4012ea:	600b      	str	r3, [r1, #0]
  4012ec:	4770      	bx	lr
  4012ee:	bf00      	nop
  4012f0:	400e0400 	.word	0x400e0400
  4012f4:	400e1410 	.word	0x400e1410
  4012f8:	20000074 	.word	0x20000074
  4012fc:	00b71b00 	.word	0x00b71b00
  401300:	003d0900 	.word	0x003d0900
  401304:	007a1200 	.word	0x007a1200
  401308:	aaaaaaab 	.word	0xaaaaaaab

0040130c <system_init_flash>:
 * Initialize flash.
 */
void system_init_flash(uint32_t ul_clk)
{
	/* Set FWS for embedded Flash access according to operating frequency */
	if (ul_clk < CHIP_FREQ_FWS_0) {
  40130c:	4b0f      	ldr	r3, [pc, #60]	; (40134c <system_init_flash+0x40>)
  40130e:	4298      	cmp	r0, r3
  401310:	d804      	bhi.n	40131c <system_init_flash+0x10>
		EFC->EEFC_FMR = EEFC_FMR_FWS(0)|EEFC_FMR_CLOE;
  401312:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
  401316:	4b0e      	ldr	r3, [pc, #56]	; (401350 <system_init_flash+0x44>)
  401318:	601a      	str	r2, [r3, #0]
  40131a:	4770      	bx	lr
	} else {
		if (ul_clk < CHIP_FREQ_FWS_1) {
  40131c:	4b0d      	ldr	r3, [pc, #52]	; (401354 <system_init_flash+0x48>)
  40131e:	4298      	cmp	r0, r3
  401320:	d803      	bhi.n	40132a <system_init_flash+0x1e>
			EFC->EEFC_FMR = EEFC_FMR_FWS(1)|EEFC_FMR_CLOE;
  401322:	4a0d      	ldr	r2, [pc, #52]	; (401358 <system_init_flash+0x4c>)
  401324:	4b0a      	ldr	r3, [pc, #40]	; (401350 <system_init_flash+0x44>)
  401326:	601a      	str	r2, [r3, #0]
  401328:	4770      	bx	lr
		} else {
			if (ul_clk < CHIP_FREQ_FWS_2) {
  40132a:	4b0c      	ldr	r3, [pc, #48]	; (40135c <system_init_flash+0x50>)
  40132c:	4298      	cmp	r0, r3
  40132e:	d803      	bhi.n	401338 <system_init_flash+0x2c>
				EFC->EEFC_FMR = EEFC_FMR_FWS(2)|EEFC_FMR_CLOE;
  401330:	4a0b      	ldr	r2, [pc, #44]	; (401360 <system_init_flash+0x54>)
  401332:	4b07      	ldr	r3, [pc, #28]	; (401350 <system_init_flash+0x44>)
  401334:	601a      	str	r2, [r3, #0]
  401336:	4770      	bx	lr
			} else {
				if (ul_clk < CHIP_FREQ_FWS_3) {
  401338:	4b0a      	ldr	r3, [pc, #40]	; (401364 <system_init_flash+0x58>)
  40133a:	4298      	cmp	r0, r3
					EFC->EEFC_FMR = EEFC_FMR_FWS(3)|EEFC_FMR_CLOE;
  40133c:	bf94      	ite	ls
  40133e:	4a0a      	ldrls	r2, [pc, #40]	; (401368 <system_init_flash+0x5c>)
				} else {
					EFC->EEFC_FMR = EEFC_FMR_FWS(4)|EEFC_FMR_CLOE;
  401340:	f04f 2204 	movhi.w	r2, #67109888	; 0x4000400
  401344:	4b02      	ldr	r3, [pc, #8]	; (401350 <system_init_flash+0x44>)
  401346:	601a      	str	r2, [r3, #0]
  401348:	4770      	bx	lr
  40134a:	bf00      	nop
  40134c:	01312cff 	.word	0x01312cff
  401350:	400e0a00 	.word	0x400e0a00
  401354:	026259ff 	.word	0x026259ff
  401358:	04000100 	.word	0x04000100
  40135c:	039386ff 	.word	0x039386ff
  401360:	04000200 	.word	0x04000200
  401364:	04c4b3ff 	.word	0x04c4b3ff
  401368:	04000300 	.word	0x04000300

0040136c <init_IO_int>:
 #define MAX7314_slaveAddress 0b0100000 //7bit address when AD0 = GND

 void init_IO_int(){

	//enable clock for PIOB
	REG_PMC_PCER0 |= PMC_PCER0_PID12;
  40136c:	4a17      	ldr	r2, [pc, #92]	; (4013cc <init_IO_int+0x60>)
  40136e:	6813      	ldr	r3, [r2, #0]
  401370:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
  401374:	6013      	str	r3, [r2, #0]

	//Set up PB10 as Button IO Expander Input
	REG_PIOB_PER |= PIO_PER_P10; //enable PIO controller
  401376:	f502 623f 	add.w	r2, r2, #3056	; 0xbf0
  40137a:	6813      	ldr	r3, [r2, #0]
  40137c:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
  401380:	6013      	str	r3, [r2, #0]
	REG_PIOB_ODR |= PIO_ODR_P10; //disable output
  401382:	3214      	adds	r2, #20
  401384:	6813      	ldr	r3, [r2, #0]
  401386:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
  40138a:	6013      	str	r3, [r2, #0]
	REG_PIOB_PPDDR |= PIO_PPDDR_P10; //disable pull-down resistor
  40138c:	327c      	adds	r2, #124	; 0x7c
  40138e:	6813      	ldr	r3, [r2, #0]
  401390:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
  401394:	6013      	str	r3, [r2, #0]
	REG_PIOB_PUER |= PIO_PUER_P10;	//enable pull-up resistor
  401396:	3a2c      	subs	r2, #44	; 0x2c
  401398:	6813      	ldr	r3, [r2, #0]
  40139a:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
  40139e:	6013      	str	r3, [r2, #0]
	REG_PIOB_IFSCER |= PIO_IFSCER_P10; //turn on slow clock debounce
  4013a0:	3220      	adds	r2, #32
  4013a2:	6813      	ldr	r3, [r2, #0]
  4013a4:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
  4013a8:	6013      	str	r3, [r2, #0]
	REG_PIOB_IFER |= PIO_IFER_P10;	//start debounce filter
  4013aa:	3a64      	subs	r2, #100	; 0x64
  4013ac:	6813      	ldr	r3, [r2, #0]
  4013ae:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
  4013b2:	6013      	str	r3, [r2, #0]

	uint32_t flag_clear = REG_PIOB_ISR;	//clear left over interrupt flags
  4013b4:	4b06      	ldr	r3, [pc, #24]	; (4013d0 <init_IO_int+0x64>)
  4013b6:	681b      	ldr	r3, [r3, #0]

	//Enable interrupts for PB10
	REG_PIOB_IER |= PIO_IER_P10;			//enable input level change interrupt
  4013b8:	3220      	adds	r2, #32
  4013ba:	6813      	ldr	r3, [r2, #0]
  4013bc:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
  4013c0:	6013      	str	r3, [r2, #0]
  4013c2:	f44f 5280 	mov.w	r2, #4096	; 0x1000
  4013c6:	4b03      	ldr	r3, [pc, #12]	; (4013d4 <init_IO_int+0x68>)
  4013c8:	601a      	str	r2, [r3, #0]
  4013ca:	4770      	bx	lr
  4013cc:	400e0410 	.word	0x400e0410
  4013d0:	400e104c 	.word	0x400e104c
  4013d4:	e000e100 	.word	0xe000e100

004013d8 <i2c_init>:

 }

 void i2c_init(){

	REG_TWI0_CR = TWI_CR_SWRST;
  4013d8:	4b12      	ldr	r3, [pc, #72]	; (401424 <i2c_init+0x4c>)
  4013da:	2280      	movs	r2, #128	; 0x80
  4013dc:	601a      	str	r2, [r3, #0]

	//enable peripheral clock for i2c using TWI0
	REG_PMC_PCER0 |= PMC_PCER0_PID19;
  4013de:	4912      	ldr	r1, [pc, #72]	; (401428 <i2c_init+0x50>)
  4013e0:	680a      	ldr	r2, [r1, #0]
  4013e2:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
  4013e6:	600a      	str	r2, [r1, #0]

	//disable GPIO control of i2c pins
	REG_PIOA_PDR |= PIO_PDR_P3;
  4013e8:	4a10      	ldr	r2, [pc, #64]	; (40142c <i2c_init+0x54>)
  4013ea:	6811      	ldr	r1, [r2, #0]
  4013ec:	f041 0108 	orr.w	r1, r1, #8
  4013f0:	6011      	str	r1, [r2, #0]
	REG_PIOA_PDR |= PIO_PDR_P4;
  4013f2:	6811      	ldr	r1, [r2, #0]
  4013f4:	f041 0110 	orr.w	r1, r1, #16
  4013f8:	6011      	str	r1, [r2, #0]

	// tlow = ((CLDIV * 2^CKDIV) + 4) * Tper
	// thigh = ((CHDIV * 2^CKDIV) + 4) * Tper
	// thigh = tlow => 400kHz (supposedly...)
	//set TWI0 clock to 400kHz (supported by IO expander)
	REG_TWI0_CWGR |= TWI_CWGR_CLDIV(46);
  4013fa:	f5a2 2248 	sub.w	r2, r2, #819200	; 0xc8000
  4013fe:	f6a2 52f4 	subw	r2, r2, #3572	; 0xdf4
  401402:	6811      	ldr	r1, [r2, #0]
  401404:	f041 012e 	orr.w	r1, r1, #46	; 0x2e
  401408:	6011      	str	r1, [r2, #0]
	REG_TWI0_CWGR |= TWI_CWGR_CHDIV(46);
  40140a:	6811      	ldr	r1, [r2, #0]
  40140c:	f441 5138 	orr.w	r1, r1, #11776	; 0x2e00
  401410:	6011      	str	r1, [r2, #0]

	//disable slave mode & enable master mode
	REG_TWI0_CR |= TWI_CR_SVDIS;
  401412:	681a      	ldr	r2, [r3, #0]
  401414:	f042 0220 	orr.w	r2, r2, #32
  401418:	601a      	str	r2, [r3, #0]
	REG_TWI0_CR |= TWI_CR_MSEN;
  40141a:	681a      	ldr	r2, [r3, #0]
  40141c:	f042 0204 	orr.w	r2, r2, #4
  401420:	601a      	str	r2, [r3, #0]
  401422:	4770      	bx	lr
  401424:	40018000 	.word	0x40018000
  401428:	400e0410 	.word	0x400e0410
  40142c:	400e0e04 	.word	0x400e0e04

00401430 <i2c_stop>:
 }

 void i2c_stop(){
	REG_TWI0_CR |= TWI_CR_STOP;
  401430:	4a02      	ldr	r2, [pc, #8]	; (40143c <i2c_stop+0xc>)
  401432:	6813      	ldr	r3, [r2, #0]
  401434:	f043 0302 	orr.w	r3, r3, #2
  401438:	6013      	str	r3, [r2, #0]
  40143a:	4770      	bx	lr
  40143c:	40018000 	.word	0x40018000

00401440 <i2c_start>:
 }

 void i2c_start(uint8_t slave_addr, uint8_t mread){
	//set slave address
	REG_TWI0_MMR |= TWI_MMR_DADR(slave_addr);
  401440:	4a0c      	ldr	r2, [pc, #48]	; (401474 <i2c_start+0x34>)
  401442:	6813      	ldr	r3, [r2, #0]
  401444:	0400      	lsls	r0, r0, #16
  401446:	f400 00fe 	and.w	r0, r0, #8323072	; 0x7f0000
  40144a:	4303      	orrs	r3, r0
  40144c:	6013      	str	r3, [r2, #0]

	//set read/write
	if (mread == write){
  40144e:	b921      	cbnz	r1, 40145a <i2c_start+0x1a>
		REG_TWI0_MMR &= ~TWI_MMR_MREAD;
  401450:	6813      	ldr	r3, [r2, #0]
  401452:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
  401456:	6013      	str	r3, [r2, #0]
  401458:	4770      	bx	lr
	}
	else if (mread == read){
  40145a:	2901      	cmp	r1, #1
  40145c:	d109      	bne.n	401472 <i2c_start+0x32>
		REG_TWI0_MMR |= TWI_MMR_MREAD;
  40145e:	4a05      	ldr	r2, [pc, #20]	; (401474 <i2c_start+0x34>)
  401460:	6813      	ldr	r3, [r2, #0]
  401462:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
  401466:	6013      	str	r3, [r2, #0]
		REG_TWI0_CR |= TWI_CR_START;
  401468:	3a04      	subs	r2, #4
  40146a:	6813      	ldr	r3, [r2, #0]
  40146c:	f043 0301 	orr.w	r3, r3, #1
  401470:	6013      	str	r3, [r2, #0]
  401472:	4770      	bx	lr
  401474:	40018004 	.word	0x40018004

00401478 <i2c_write>:
 }

 void i2c_write(uint8_t data){

	//send data or register address
	REG_TWI0_THR |= data;
  401478:	4a04      	ldr	r2, [pc, #16]	; (40148c <i2c_write+0x14>)
  40147a:	6813      	ldr	r3, [r2, #0]
  40147c:	4318      	orrs	r0, r3
  40147e:	6010      	str	r0, [r2, #0]

	//wait fro acknowledge
	while(!(REG_TWI0_SR & TWI_SR_TXRDY));
  401480:	3a14      	subs	r2, #20
  401482:	6813      	ldr	r3, [r2, #0]
  401484:	f013 0f04 	tst.w	r3, #4
  401488:	d0fb      	beq.n	401482 <i2c_write+0xa>
 }
  40148a:	4770      	bx	lr
  40148c:	40018034 	.word	0x40018034

00401490 <i2c_writeStop>:

 void i2c_writeStop(uint8_t data){
  401490:	b508      	push	{r3, lr}

	//send data or register address
	REG_TWI0_THR |= data;
  401492:	4a08      	ldr	r2, [pc, #32]	; (4014b4 <i2c_writeStop+0x24>)
  401494:	6813      	ldr	r3, [r2, #0]
  401496:	4318      	orrs	r0, r3
  401498:	6010      	str	r0, [r2, #0]

	//wait for acknowledge
	while(!(REG_TWI0_SR & TWI_SR_TXRDY));
  40149a:	3a14      	subs	r2, #20
  40149c:	6813      	ldr	r3, [r2, #0]
  40149e:	f013 0f04 	tst.w	r3, #4
  4014a2:	d0fb      	beq.n	40149c <i2c_writeStop+0xc>

	//send stop bit before data is written
	i2c_stop();
  4014a4:	4b04      	ldr	r3, [pc, #16]	; (4014b8 <i2c_writeStop+0x28>)
  4014a6:	4798      	blx	r3

	while(!(REG_TWI0_SR & TWI_SR_TXCOMP));
  4014a8:	4a04      	ldr	r2, [pc, #16]	; (4014bc <i2c_writeStop+0x2c>)
  4014aa:	6813      	ldr	r3, [r2, #0]
  4014ac:	f013 0f01 	tst.w	r3, #1
  4014b0:	d0fb      	beq.n	4014aa <i2c_writeStop+0x1a>
 }
  4014b2:	bd08      	pop	{r3, pc}
  4014b4:	40018034 	.word	0x40018034
  4014b8:	00401431 	.word	0x00401431
  4014bc:	40018020 	.word	0x40018020

004014c0 <main>:
uint8_t brightness = 0x07;
uint8_t dataL;
uint8_t dataH;

int main (void)
{
  4014c0:	b508      	push	{r3, lr}
	sysclk_init();				//initialize system clock
  4014c2:	4b19      	ldr	r3, [pc, #100]	; (401528 <main+0x68>)
  4014c4:	4798      	blx	r3
	WDT->WDT_MR = WDT_MR_WDDIS; //disable watchdog timer
  4014c6:	f44f 4200 	mov.w	r2, #32768	; 0x8000
  4014ca:	4b18      	ldr	r3, [pc, #96]	; (40152c <main+0x6c>)
  4014cc:	605a      	str	r2, [r3, #4]

	board_init();				//board init (currently empty)
  4014ce:	4b18      	ldr	r3, [pc, #96]	; (401530 <main+0x70>)
  4014d0:	4798      	blx	r3

	SPI_led_init();
  4014d2:	4b18      	ldr	r3, [pc, #96]	; (401534 <main+0x74>)
  4014d4:	4798      	blx	r3
	leds_update_display();
  4014d6:	4b18      	ldr	r3, [pc, #96]	; (401538 <main+0x78>)
  4014d8:	4798      	blx	r3

	timers_init();				//initiate timer for Flashing LED on PA20
  4014da:	4b18      	ldr	r3, [pc, #96]	; (40153c <main+0x7c>)
  4014dc:	4798      	blx	r3
	update_timers(bpm);
  4014de:	4b18      	ldr	r3, [pc, #96]	; (401540 <main+0x80>)
  4014e0:	8818      	ldrh	r0, [r3, #0]
  4014e2:	4b18      	ldr	r3, [pc, #96]	; (401544 <main+0x84>)
  4014e4:	4798      	blx	r3

	REG_PIOB_PER |= PIO_PER_P3; //enable PIO controller on PB14
  4014e6:	4a18      	ldr	r2, [pc, #96]	; (401548 <main+0x88>)
  4014e8:	6813      	ldr	r3, [r2, #0]
  4014ea:	f043 0308 	orr.w	r3, r3, #8
  4014ee:	6013      	str	r3, [r2, #0]
	REG_PIOB_OER |= PIO_PER_P3; //enable output on pin PB14
  4014f0:	3210      	adds	r2, #16
  4014f2:	6813      	ldr	r3, [r2, #0]
  4014f4:	f043 0308 	orr.w	r3, r3, #8
  4014f8:	6013      	str	r3, [r2, #0]
	REG_PIOB_SODR |= PIO_PER_P3; //set output high on PB14 as default
  4014fa:	3220      	adds	r2, #32
  4014fc:	6813      	ldr	r3, [r2, #0]
  4014fe:	f043 0308 	orr.w	r3, r3, #8
  401502:	6013      	str	r3, [r2, #0]
	Encoder_init();				//initialize encoders
  401504:	4b11      	ldr	r3, [pc, #68]	; (40154c <main+0x8c>)
  401506:	4798      	blx	r3

	i2c_init();
  401508:	4b11      	ldr	r3, [pc, #68]	; (401550 <main+0x90>)
  40150a:	4798      	blx	r3
	init_IO_int();
  40150c:	4b11      	ldr	r3, [pc, #68]	; (401554 <main+0x94>)
  40150e:	4798      	blx	r3

	while (1)
	{
		//wait for button interrupt to read data
		//configure register to enable interrupt
	i2c_start(MAX7314_slaveAddress, 0);
  401510:	4e11      	ldr	r6, [pc, #68]	; (401558 <main+0x98>)
	
	i2c_write(MAX7314_configRegister);
  401512:	4d12      	ldr	r5, [pc, #72]	; (40155c <main+0x9c>)

	i2c_writeStop(0b00001000);
  401514:	4c12      	ldr	r4, [pc, #72]	; (401560 <main+0xa0>)

	while (1)
	{
		//wait for button interrupt to read data
		//configure register to enable interrupt
	i2c_start(MAX7314_slaveAddress, 0);
  401516:	2100      	movs	r1, #0
  401518:	2010      	movs	r0, #16
  40151a:	47b0      	blx	r6
	
	i2c_write(MAX7314_configRegister);
  40151c:	200f      	movs	r0, #15
  40151e:	47a8      	blx	r5

	i2c_writeStop(0b00001000);
  401520:	2008      	movs	r0, #8
  401522:	47a0      	blx	r4
  401524:	e7f7      	b.n	401516 <main+0x56>
  401526:	bf00      	nop
  401528:	00401019 	.word	0x00401019
  40152c:	400e1450 	.word	0x400e1450
  401530:	00401015 	.word	0x00401015
  401534:	00400e99 	.word	0x00400e99
  401538:	00400a29 	.word	0x00400a29
  40153c:	00400f21 	.word	0x00400f21
  401540:	20000078 	.word	0x20000078
  401544:	00400fa5 	.word	0x00400fa5
  401548:	400e1000 	.word	0x400e1000
  40154c:	00400191 	.word	0x00400191
  401550:	004013d9 	.word	0x004013d9
  401554:	0040136d 	.word	0x0040136d
  401558:	00401441 	.word	0x00401441
  40155c:	00401479 	.word	0x00401479
  401560:	00401491 	.word	0x00401491

00401564 <PIOB_Handler>:
	}
}

 void PIOB_Handler(){

	 uint32_t status = REG_PIOB_ISR;	//read PIOB interrupt status & clear interrupt flags
  401564:	4b01      	ldr	r3, [pc, #4]	; (40156c <PIOB_Handler+0x8>)
  401566:	681b      	ldr	r3, [r3, #0]
  401568:	4770      	bx	lr
  40156a:	bf00      	nop
  40156c:	400e104c 	.word	0x400e104c

00401570 <__libc_init_array>:
  401570:	b570      	push	{r4, r5, r6, lr}
  401572:	4e0f      	ldr	r6, [pc, #60]	; (4015b0 <__libc_init_array+0x40>)
  401574:	4d0f      	ldr	r5, [pc, #60]	; (4015b4 <__libc_init_array+0x44>)
  401576:	1b76      	subs	r6, r6, r5
  401578:	10b6      	asrs	r6, r6, #2
  40157a:	bf18      	it	ne
  40157c:	2400      	movne	r4, #0
  40157e:	d005      	beq.n	40158c <__libc_init_array+0x1c>
  401580:	3401      	adds	r4, #1
  401582:	f855 3b04 	ldr.w	r3, [r5], #4
  401586:	4798      	blx	r3
  401588:	42a6      	cmp	r6, r4
  40158a:	d1f9      	bne.n	401580 <__libc_init_array+0x10>
  40158c:	4e0a      	ldr	r6, [pc, #40]	; (4015b8 <__libc_init_array+0x48>)
  40158e:	4d0b      	ldr	r5, [pc, #44]	; (4015bc <__libc_init_array+0x4c>)
  401590:	1b76      	subs	r6, r6, r5
  401592:	f000 f88f 	bl	4016b4 <_init>
  401596:	10b6      	asrs	r6, r6, #2
  401598:	bf18      	it	ne
  40159a:	2400      	movne	r4, #0
  40159c:	d006      	beq.n	4015ac <__libc_init_array+0x3c>
  40159e:	3401      	adds	r4, #1
  4015a0:	f855 3b04 	ldr.w	r3, [r5], #4
  4015a4:	4798      	blx	r3
  4015a6:	42a6      	cmp	r6, r4
  4015a8:	d1f9      	bne.n	40159e <__libc_init_array+0x2e>
  4015aa:	bd70      	pop	{r4, r5, r6, pc}
  4015ac:	bd70      	pop	{r4, r5, r6, pc}
  4015ae:	bf00      	nop
  4015b0:	004016c0 	.word	0x004016c0
  4015b4:	004016c0 	.word	0x004016c0
  4015b8:	004016c8 	.word	0x004016c8
  4015bc:	004016c0 	.word	0x004016c0

004015c0 <register_fini>:
  4015c0:	4b02      	ldr	r3, [pc, #8]	; (4015cc <register_fini+0xc>)
  4015c2:	b113      	cbz	r3, 4015ca <register_fini+0xa>
  4015c4:	4802      	ldr	r0, [pc, #8]	; (4015d0 <register_fini+0x10>)
  4015c6:	f000 b805 	b.w	4015d4 <atexit>
  4015ca:	4770      	bx	lr
  4015cc:	00000000 	.word	0x00000000
  4015d0:	004015e1 	.word	0x004015e1

004015d4 <atexit>:
  4015d4:	2300      	movs	r3, #0
  4015d6:	4601      	mov	r1, r0
  4015d8:	461a      	mov	r2, r3
  4015da:	4618      	mov	r0, r3
  4015dc:	f000 b814 	b.w	401608 <__register_exitproc>

004015e0 <__libc_fini_array>:
  4015e0:	b538      	push	{r3, r4, r5, lr}
  4015e2:	4d07      	ldr	r5, [pc, #28]	; (401600 <__libc_fini_array+0x20>)
  4015e4:	4c07      	ldr	r4, [pc, #28]	; (401604 <__libc_fini_array+0x24>)
  4015e6:	1b2c      	subs	r4, r5, r4
  4015e8:	10a4      	asrs	r4, r4, #2
  4015ea:	d005      	beq.n	4015f8 <__libc_fini_array+0x18>
  4015ec:	3c01      	subs	r4, #1
  4015ee:	f855 3d04 	ldr.w	r3, [r5, #-4]!
  4015f2:	4798      	blx	r3
  4015f4:	2c00      	cmp	r4, #0
  4015f6:	d1f9      	bne.n	4015ec <__libc_fini_array+0xc>
  4015f8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  4015fc:	f000 b864 	b.w	4016c8 <_fini>
  401600:	004016d8 	.word	0x004016d8
  401604:	004016d4 	.word	0x004016d4

00401608 <__register_exitproc>:
  401608:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  40160c:	4c25      	ldr	r4, [pc, #148]	; (4016a4 <__register_exitproc+0x9c>)
  40160e:	6825      	ldr	r5, [r4, #0]
  401610:	f8d5 4148 	ldr.w	r4, [r5, #328]	; 0x148
  401614:	4606      	mov	r6, r0
  401616:	4688      	mov	r8, r1
  401618:	4692      	mov	sl, r2
  40161a:	4699      	mov	r9, r3
  40161c:	b3c4      	cbz	r4, 401690 <__register_exitproc+0x88>
  40161e:	6860      	ldr	r0, [r4, #4]
  401620:	281f      	cmp	r0, #31
  401622:	dc17      	bgt.n	401654 <__register_exitproc+0x4c>
  401624:	1c43      	adds	r3, r0, #1
  401626:	b176      	cbz	r6, 401646 <__register_exitproc+0x3e>
  401628:	eb04 0580 	add.w	r5, r4, r0, lsl #2
  40162c:	2201      	movs	r2, #1
  40162e:	f8c5 a088 	str.w	sl, [r5, #136]	; 0x88
  401632:	f8d4 1188 	ldr.w	r1, [r4, #392]	; 0x188
  401636:	4082      	lsls	r2, r0
  401638:	4311      	orrs	r1, r2
  40163a:	2e02      	cmp	r6, #2
  40163c:	f8c4 1188 	str.w	r1, [r4, #392]	; 0x188
  401640:	f8c5 9108 	str.w	r9, [r5, #264]	; 0x108
  401644:	d01e      	beq.n	401684 <__register_exitproc+0x7c>
  401646:	3002      	adds	r0, #2
  401648:	6063      	str	r3, [r4, #4]
  40164a:	f844 8020 	str.w	r8, [r4, r0, lsl #2]
  40164e:	2000      	movs	r0, #0
  401650:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  401654:	4b14      	ldr	r3, [pc, #80]	; (4016a8 <__register_exitproc+0xa0>)
  401656:	b303      	cbz	r3, 40169a <__register_exitproc+0x92>
  401658:	f44f 70c8 	mov.w	r0, #400	; 0x190
  40165c:	f3af 8000 	nop.w
  401660:	4604      	mov	r4, r0
  401662:	b1d0      	cbz	r0, 40169a <__register_exitproc+0x92>
  401664:	f8d5 3148 	ldr.w	r3, [r5, #328]	; 0x148
  401668:	2700      	movs	r7, #0
  40166a:	e880 0088 	stmia.w	r0, {r3, r7}
  40166e:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
  401672:	4638      	mov	r0, r7
  401674:	2301      	movs	r3, #1
  401676:	f8c4 7188 	str.w	r7, [r4, #392]	; 0x188
  40167a:	f8c4 718c 	str.w	r7, [r4, #396]	; 0x18c
  40167e:	2e00      	cmp	r6, #0
  401680:	d0e1      	beq.n	401646 <__register_exitproc+0x3e>
  401682:	e7d1      	b.n	401628 <__register_exitproc+0x20>
  401684:	f8d4 118c 	ldr.w	r1, [r4, #396]	; 0x18c
  401688:	430a      	orrs	r2, r1
  40168a:	f8c4 218c 	str.w	r2, [r4, #396]	; 0x18c
  40168e:	e7da      	b.n	401646 <__register_exitproc+0x3e>
  401690:	f505 74a6 	add.w	r4, r5, #332	; 0x14c
  401694:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
  401698:	e7c1      	b.n	40161e <__register_exitproc+0x16>
  40169a:	f04f 30ff 	mov.w	r0, #4294967295
  40169e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  4016a2:	bf00      	nop
  4016a4:	004016b0 	.word	0x004016b0
  4016a8:	00000000 	.word	0x00000000
  4016ac:	00000043 	.word	0x00000043

004016b0 <_global_impure_ptr>:
  4016b0:	20000080                                ... 

004016b4 <_init>:
  4016b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  4016b6:	bf00      	nop
  4016b8:	bcf8      	pop	{r3, r4, r5, r6, r7}
  4016ba:	bc08      	pop	{r3}
  4016bc:	469e      	mov	lr, r3
  4016be:	4770      	bx	lr

004016c0 <__init_array_start>:
  4016c0:	004015c1 	.word	0x004015c1

004016c4 <__frame_dummy_init_array_entry>:
  4016c4:	004000e5                                ..@.

004016c8 <_fini>:
  4016c8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  4016ca:	bf00      	nop
  4016cc:	bcf8      	pop	{r3, r4, r5, r6, r7}
  4016ce:	bc08      	pop	{r3}
  4016d0:	469e      	mov	lr, r3
  4016d2:	4770      	bx	lr

004016d4 <__fini_array_start>:
  4016d4:	004000c1 	.word	0x004000c1

Disassembly of section .relocate:

20000000 <portable_delay_cycles>:
RAMFUNC
void portable_delay_cycles(unsigned long n)
{
	UNUSED(n);

	__asm (
20000000:	f3bf 8f5f 	dmb	sy
20000004:	3801      	subs	r0, #1
20000006:	d1fb      	bne.n	20000000 <portable_delay_cycles>
20000008:	4770      	bx	lr
2000000a:	bf00      	nop

2000000c <leds_data_1>:
2000000c:	0000 0000 3fff 0000 0000 0000 0000 0000     .....?..........
2000001c:	3fff 0000 0000 0000                         .?......

20000024 <leds_data_2>:
20000024:	0000 0000 3fff 0000 0000 0000 0000 0000     .....?..........
20000034:	3fff 0000 0000 0000                         .?......

2000003c <leds_data_3>:
	...
20000044:	0000 3fff 0000 0000 3fff 0000 0000 3fff     ...?.....?.....?

20000054 <leds_data_4>:
20000054:	0000 0000 3fff 0000 0000 0000 0000 0000     .....?..........
20000064:	0000 0000 0000 3fff                         .......?

2000006c <leds_prev_data>:
2000006c:	0000 0000 0fff 0000                         ........

20000074 <SystemCoreClock>:
20000074:	0900 003d                                   ..=.

20000078 <bpm>:
20000078:	0078 0000 0000 0000                         x.......

20000080 <impure_data>:
20000080:	0000 0000 036c 2000 03d4 2000 043c 2000     ....l.. ... <.. 
	...
200000b4:	16ac 0040 0000 0000 0000 0000 0000 0000     ..@.............
	...
20000128:	0001 0000 0000 0000 330e abcd 1234 e66d     .........3..4.m.
20000138:	deec 0005 000b 0000 0000 0000 0000 0000     ................
	...
